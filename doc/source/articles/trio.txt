

Three Paradigms for Working with Collections of DataFrames
The Bus, Batch, & Quilt: A Trio of Tools for Working with Collections of DataFrames
The Bus, Batch, & Quilt: A Trio of Multi-Frame Containers
=====================================================================================


It is common in DataFrame processing routines to work with collections of tables, such as a multi-year dataset with a single table per year, or historical stock data with table per stock. We might need to use data from multiple tables found in a database or XLSX file. This presentation introduces three novel containers for working with such collections of DataFrames: the Bus, Batch, and Quilt.


In some situations, hierarchical indices can be used to bring multiple tables into a single DataFrame, but this may not be practical for performance: efficient data handling may require having only a few tables loaded at a time, and hierarchical indices incur overhead. In other situations, heterogenous schemas may not permit any reasonable combination into a single table.

The Bus, Batch, and Quilt are specialized for different data layouts and usage contexts, and each offers significant performance opportunities for flexible memory usage and parallel processing. As familiy of multi-frame containers (MFCs), they cover three core paradigms for working with collections of DataFrames. Because the are interrelated, I describe them as a "trio."

In addition, all three tools provide the same interfaces for reading from, and writing to, multi-table storage formats such as XLSX, SQLite, HDF5, or zipped containers of pickle, Parquet, or delimited-text files.

These tools evolved from the context of my work: processing financial data and modelling investment systems. There, data sets are naturally partitioned by date or characteristic. For historical simulations, the data needed can be large. The Bus, Batch, and Quilt have provided convenient and efficient tools for this domain, without the overhead of moving to multi-machine architectures like Dask.

While these containers are implemented in the Python StaticFrame package (a Pandas alternative that offers immutable DataFrames), the abstractions are useful for application in any DataFrame or table processing library. StaticFrame calls DataFrames simply "Frames," and that convention will be used in this presentation.


Sample Data
___________________________

We will use the World Happiness Report dataset via Kaggle to demonstrate these containers. The file "archive.zip" is available at https://www.kaggle.com/unsdsn/world-happiness or via the `kaggle` command-line app::

    kaggle datasets download -d unsdsn/world-happiness

After creating a `StoreConfig` to specify table and archive characteristics, we can load the zip directly into a Bus to get started. While zip archives of CSV files are convenient, they are far less efficient than zip archives of parquet or pickle files.

>>> import static_frame as sf
>>> config = sf.StoreConfig(index_depth=1, label_decoder=int, label_encoder=str)
>>> bus = sf.Bus.from_zip_csv('archive.zip', config=config)
>>> bus
<Bus>
<Index>
2015    <FrameDeferred>
2016    <FrameDeferred>
2017    <FrameDeferred>
2018    <FrameDeferred>
2019    <FrameDeferred>
<int64> <object>

While essentially representing the same kind of data, the component tables in this archive have inconsistent columns and column naming. We can normalize each table to four columns, and assign an index with the following Frame-processing function:

    def normalize(f: sf.Frame) -> sf.Frame:
        fields = ['country', 'score', 'rank', 'gdp']

        def relabel(label):
            for field in fields:
                if field in label.lower():
                    return field
            return label

        return f.relabel(columns=relabel)[fields].set_index(fields[0], drop=True)

Given this function we can reload the Bus by using the Batch to apply this function to each table:

>>> bus = sf.Batch.from_zip_csv('archive.zip', config=config).apply(normalize).to_bus()



Relation to Other Containers
_______________________________


The Bus can be thought of as an ordered dictionary (or Series) of Frames, permitting random access by label. When reading from a file store, Frames are loaded lazily, only when accessed, and can be configured to only hold strong references to a limited number of Frames defined by the ``max_persist`` argument. This permits limiting the total memory loaded by the Bus. As shown above, initially loading "archive.zip" shows five ``FrameDeferred`` objects: Frames that are labelled but not yet loaded.

As the Bus supports reading from and writing to XLSX and HDF5 (as well as other formats), it serves the same purpose as the Pandas ``ExcelWriter`` and ``HDFStore`` interfaces, but provides a more general and consistent interface between those storage types (as well as many others).

The Batch can be thought of as a generator of pairs of label and Frame. The generator is only iterated when creating a composite Frame with ``Batch.to_frame`` or using dictionary like methods: ``keys``, ``items``, and ``values``. All other method calls or operator applications are composed and deferred in a new Batch, composing the operation upon the stored iterator.

The Batch is related to pandas DataFrameGroupBy and Rolling objects: interfaces that result from configuring a group by or rolling window operation, that then expose function application on those groups or windows. The Batch generalizes this utility for those cases as well as any iterator of labels and Frames.

The Quilt can be thought of as a Frame built from many smaller Frames, and aligned either vertically or horizontally: a virtual concatenation of tables along an axis. The Quilt exposes a subset of the Frame interface. As the Quilt manages reading those smaller Frames though a contained Bus, the Bus can be configured with ``max_persist`` to limit the number of Frames loaded, permitting doing operations on a "virtual" Frame that might not be possible to load into memory.


Shape Characteristics
_______________________

Another way of understanding the trio is in terms of shape and iteration characteristics. The Bus and Batch are one-dimensional collections of Frames; the Quilt presents a two-dimensional Frame. While the shape of the Bus and Batch is the number of Frames, the shape of the Quilt depends on its axis of orientation. While each container is iterable, only the Batch is an iterator: its shape cannot be known until iteration is completed.

For n Frame of shape (x, y)
+---------+------+------+------------------+
|         |Bus   |Batch |Quilt             |
+=========+======+======+==================+
|ndim     |1     |1     |2                 |
+---------+------+------+------------------+
|shape    |(n,)  |(n,)  |(xn, y) or (x, yn)|
+---------+------+------+------------------+
|Iterable |True  |True  |True              |
+---------+------+------+------------------+
|Iterator |False |True  |False             |
+---------+------+------+------------------+


Initialization
_______________________

The Bus, Batch, and Quilt all share the same file-based constructors and exporters, such as `from_zip_csv()` shown above or `from_xlsx()`; each constructor has a corresponding exporter: e.g., `to_zip_csv()` or `to_xlsx()`, respectively. The following table summarize the constructors and exporters available.

File-Based Constructors & Exporters
+-----------------+--------------+
|Constructor      |Exporter      |
+=================+==============+
|from_zip_tsv     |to_zip_tsv    |
+-----------------+--------------+
|from_zip_csv     |to_zip_csv    |
+-----------------+--------------+
|from_zip_pickle  |to_zip_pickle |
+-----------------+--------------+
|from_zip_parquet |to_zip_parquet|
+-----------------+--------------+
|from_xlsx        |to_xlsx       |
+-----------------+--------------+
|from_sqlite      |to_sqlite     |
+-----------------+--------------+
|from_hdf5        |to_hdf5       |
+-----------------+--------------+


Constructors for creating MFCs from in-memory Frames are also provided. A Batch can be initialized from any items-like iterator of pairs of label and Frame; this is can be supplied by ``items()`` on the Bus. As the Batch is a generator-like iterator, it can only be iterated once before it is exhausted. For this reason a fresh Batch will be created for each usage in subsequent examples. The following example demonstrates that, just like a generator, a Batch can only be iterated once:

>>> batch = sf.Batch(bus.items())
>>> len(tuple(batch))
5
>>> len(tuple(batch))
0


A Quilt can be initialized from a Bus, and requires specification of which axis to orient on, either vertically (axis 0) or horizontally (axis 1). Additionally, creation of a Quilt must specify if outer Frame lables should be retained with the ``retain_labels`` argument.

>>> quilt = sf.Quilt(bus, axis=0, retain_labels=True)
>>> [f.shape for f in bus.values]
[(158, 3), (157, 3), (155, 3), (156, 3), (156, 3)]
>>> quilt.shape
(782, 3)


Cross-Container Comparisons
______________________________

To better understand these containers, I will demonstrate similar operations on each. Through understanding these examples, the nature of these containers will be made clear.


Selection
...............................

The ``head(2)`` method returns three very different results with each container. The Bus, like a `Series`, returns a new `Bus` with the first two Frames. The Batch calls `head(2)` on each contained `Frame`, returning the top two rows from each contained `Frame`. The Quilt, representing the contained Frames as a contiguous, tall Frame, return the first two row of the first Frame, labelled with a hierarchical index.

>>> bus.head(2)
<Bus>
<Index>
2015    Frame
2016    Frame
<int64> <object>

>>> sf.Batch(bus.items()).head(2).to_frame()
<Frame>
<Index>                      score            rank    gdp              <<U29>
<IndexHierarchy>
2015             Switzerland 7.587            1       1.39651
2015             Iceland     7.561            2       1.30232
2016             Denmark     7.526            1       1.44178
2016             Switzerland 7.509            2       1.52733
2017             Norway      7.53700017929077 1       1.61646318435669
2017             Denmark     7.52199983596802 2       1.48238301277161
2018             Finland     7.632            1       1.305
2018             Norway      7.594            2       1.456
2019             Finland     7.769            1       1.34
2019             Denmark     7.6              2       1.383
<int64>          <<U24>      <float64>        <int64> <float64>

>> quilt.head(2)
<Frame: 2015>
<Index>                               score     rank    gdp       <<U29>
<IndexHierarchy: country>
2015                      Switzerland 7.587     1       1.39651
2015                      Iceland     7.561     2       1.30232
<int64>                   <<U24>      <float64> <int64> <float64>


The full range of `loc` and `iloc` style selection is supported from all containers, but again operating in the appropriate dimensional context of each MFC. With the Bus we can select contained Frames, with the Batch we can select from each contained Frame, and with the Quilt we can select form the virtual concatenation into a single Frame.

>>> bus[2017].tail()
<Frame: 2017>
<Index>                  score            rank    gdp               <<U29>
<Index: country>
Rwanda                   3.47099995613098 151     0.368745893239975
Syria                    3.46199989318848 152     0.777153134346008
Tanzania                 3.34899997711182 153     0.511135876178741
Burundi                  2.90499997138977 154     0.091622568666935
Central African Republic 2.69300007820129 155     0.0
<<U24>                   <float64>        <int64> <float64>

>>> sf.Batch(bus.items()).loc['Tanzania', ['score', 'rank']].to_frame()
<Frame>
<Index> score            rank      <<U29>
<Index>
2015    3.781            146.0
2016    3.666            149.0
2017    3.34899997711182 153.0
2018    3.303            153.0
2019    3.231            153.0
<int64> <float64>        <float64>

>>> quilt.loc[sf.HLoc[:, 'Tanzania'], ['score', 'rank']]
<Frame>
<Index>                            score            rank    <<U29>
<IndexHierarchy: country>
2015                      Tanzania 3.781            146
2016                      Tanzania 3.666            149
2017                      Tanzania 3.34899997711182 153
2018                      Tanzania 3.303            153
2019                      Tanzania 3.231            153
<int64>                   <<U8>    <float64>        <int64>



Iteration
...............................





Function Application
...............................





Performance
_______________________




Conclusion
_______________________






