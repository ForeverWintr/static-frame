

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>package.public.static_frame.static_frame &mdash; StaticFrame 0.1a1 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../../search.html"/>
    <link rel="top" title="StaticFrame 0.1a1 documentation" href="../../../../index.html"/>
        <link rel="up" title="Module code" href="../../../index.html"/> 

  
  <script src="../../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../../index.html" class="icon icon-home"> StaticFrame
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../overview.html">2. API Overview</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">StaticFrame</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
      <li>package.public.static_frame.static_frame</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for package.public.static_frame.static_frame</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">types</span> <span class="k">import</span> <span class="n">GeneratorType</span>
<span class="kn">import</span> <span class="nn">typing</span> <span class="k">as</span> <span class="nn">tp</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">namedtuple</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">abc</span>

<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">chain</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">zip_longest</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">product</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">wraps</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">repeat</span>
<span class="kn">from</span> <span class="nn">enum</span> <span class="k">import</span> <span class="n">Enum</span>
<span class="kn">from</span> <span class="nn">io</span> <span class="k">import</span> <span class="n">StringIO</span>
<span class="kn">from</span> <span class="nn">io</span> <span class="k">import</span> <span class="n">BytesIO</span>

<span class="kn">from</span> <span class="nn">concurrent.futures</span> <span class="k">import</span> <span class="n">ProcessPoolExecutor</span>
<span class="kn">from</span> <span class="nn">concurrent.futures</span> <span class="k">import</span> <span class="n">ThreadPoolExecutor</span>

<span class="kn">import</span> <span class="nn">operator</span> <span class="k">as</span> <span class="nn">operator_mod</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy.ma</span> <span class="k">import</span> <span class="n">MaskedArray</span>

<span class="n">_module</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="vm">__name__</span><span class="p">]</span>

<span class="c1"># target features for 0.1a1 release</span>

<span class="c1"># handle nan in object blocks with skipna processing on ufuncs</span>
<span class="c1"># allow columns asignment with getitem on FrameGO from an integer</span>
<span class="c1"># bloc() to select / assign into an 2D array with Boolean mask selection</span>
<span class="c1"># test and complete Frame.from_csv, to_csv</span>


<span class="c1"># future features</span>
<span class="c1"># Series in from_concat</span>
<span class="c1"># roll() on TypeBlocks (can be used in duplicate discovery on blocks)</span>
<span class="c1"># shift as non-wrapping roll</span>
<span class="c1"># astype: TypeBlocks, Series, Frame</span>
<span class="c1">#   Frame.astype[a:b](int)</span>

<span class="c1"># dtype.kind</span>
<span class="c1">#     A character code (one of ‘biufcmMOSUV’) identifying the general kind of data.</span>
<span class="c1">#     b 	boolean</span>
<span class="c1">#     i 	signed integer</span>
<span class="c1">#     u 	unsigned integer</span>
<span class="c1">#     f 	floating-point</span>
<span class="c1">#     c 	complex floating-point</span>
<span class="c1">#     m 	timedelta</span>
<span class="c1">#     M 	datetime</span>
<span class="c1">#     O 	object</span>
<span class="c1">#     S 	(byte-)string</span>
<span class="c1">#     U 	Unicode</span>
<span class="c1">#     V 	void</span>

<span class="n">__version__</span> <span class="o">=</span> <span class="s1">&#39;0.1.0&#39;</span>

<span class="n">_DEFAULT_SORT_KIND</span> <span class="o">=</span> <span class="s1">&#39;mergesort&#39;</span>
<span class="n">_DEFAULT_STABLE_SORT_KIND</span> <span class="o">=</span> <span class="s1">&#39;mergesort&#39;</span>

<span class="n">_DTYPE_STR_KIND</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;U&#39;</span><span class="p">,</span> <span class="s1">&#39;S&#39;</span><span class="p">)</span> <span class="c1"># S is np.bytes_</span>

<span class="n">_DTYPE_INT_KIND</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;u&#39;</span><span class="p">)</span> <span class="c1"># signed and unsigned</span>


<span class="n">_UFUNC_UNARY_OPERATORS</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s1">&#39;__pos__&#39;</span><span class="p">,</span>
        <span class="s1">&#39;__neg__&#39;</span><span class="p">,</span>
        <span class="s1">&#39;__abs__&#39;</span><span class="p">,</span>
        <span class="s1">&#39;__invert__&#39;</span><span class="p">)</span>

<span class="n">_UFUNC_BINARY_OPERATORS</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s1">&#39;__add__&#39;</span><span class="p">,</span>
        <span class="s1">&#39;__sub__&#39;</span><span class="p">,</span>
        <span class="s1">&#39;__mul__&#39;</span><span class="p">,</span>
        <span class="s1">&#39;__matmul__&#39;</span><span class="p">,</span>
        <span class="s1">&#39;__truediv__&#39;</span><span class="p">,</span>
        <span class="s1">&#39;__floordiv__&#39;</span><span class="p">,</span>
        <span class="s1">&#39;__mod__&#39;</span><span class="p">,</span>
        <span class="c1">#&#39;__divmod__&#39;, this returns two np.arrays when called on an np array</span>
        <span class="s1">&#39;__pow__&#39;</span><span class="p">,</span>
        <span class="s1">&#39;__lshift__&#39;</span><span class="p">,</span>
        <span class="s1">&#39;__rshift__&#39;</span><span class="p">,</span>
        <span class="s1">&#39;__and__&#39;</span><span class="p">,</span>
        <span class="s1">&#39;__xor__&#39;</span><span class="p">,</span>
        <span class="s1">&#39;__or__&#39;</span><span class="p">,</span>
        <span class="s1">&#39;__lt__&#39;</span><span class="p">,</span>
        <span class="s1">&#39;__le__&#39;</span><span class="p">,</span>
        <span class="s1">&#39;__eq__&#39;</span><span class="p">,</span>
        <span class="s1">&#39;__ne__&#39;</span><span class="p">,</span>
        <span class="s1">&#39;__gt__&#39;</span><span class="p">,</span>
        <span class="s1">&#39;__ge__&#39;</span><span class="p">,</span>
        <span class="p">)</span>

<span class="c1"># all reverse are binary</span>
<span class="n">_REVERSE_OPERATOR_MAP</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;__radd__&#39;</span><span class="p">:</span> <span class="s1">&#39;__add__&#39;</span><span class="p">,</span>
        <span class="s1">&#39;__rsub__&#39;</span><span class="p">:</span> <span class="s1">&#39;__sub__&#39;</span><span class="p">,</span>
        <span class="s1">&#39;__rmul__&#39;</span><span class="p">:</span> <span class="s1">&#39;__mul__&#39;</span><span class="p">,</span>
        <span class="s1">&#39;__rtruediv__&#39;</span><span class="p">:</span> <span class="s1">&#39;__truediv__&#39;</span><span class="p">,</span>
        <span class="s1">&#39;__rfloordiv__&#39;</span><span class="p">:</span> <span class="s1">&#39;__floordiv__&#39;</span><span class="p">,</span>
        <span class="p">}</span>


<span class="k">def</span> <span class="nf">_ufunc_logical_skipna</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">ufunc</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Callable</span><span class="p">,</span>
        <span class="n">skipna</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="kc">None</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given a logical (and, or) ufunc that does not support skipna, implement skipna behavior.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">ufunc</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span> <span class="ow">and</span> <span class="n">ufunc</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;unsupported ufunc&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># TODO: handle if this is ndim == 2 and has no length</span>
        <span class="k">if</span> <span class="n">ufunc</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span> <span class="c1"># any() of an empty array is False</span>

    <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span>
        <span class="c1"># if boolean execute first</span>
        <span class="k">return</span> <span class="n">ufunc</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">skipna</span><span class="p">:</span>
            <span class="c1"># replace nans with nonzero value; faster to use masked array?</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">v</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">array</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="n">ufunc</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ufunc</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="n">_DTYPE_INT_KIND</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ufunc</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

    <span class="c1"># all types other than strings or objects&quot; assume truthy</span>
    <span class="k">elif</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">!=</span> <span class="s1">&#39;O&#39;</span> <span class="ow">and</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_DTYPE_STR_KIND</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span> <span class="k">if</span> <span class="n">axis</span> <span class="k">else</span> <span class="mi">1</span><span class="p">],</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

    <span class="c1"># convert to boolean aray then process</span>
    <span class="k">if</span> <span class="n">skipna</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(((</span><span class="kc">False</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">else</span> <span class="nb">bool</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">array</span><span class="o">.</span><span class="n">flat</span><span class="p">),</span>
                <span class="n">count</span><span class="o">=</span><span class="n">array</span><span class="o">.</span><span class="n">size</span><span class="p">,</span>
                <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">((</span><span class="nb">bool</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">array</span><span class="o">.</span><span class="n">flat</span><span class="p">),</span>
                <span class="n">count</span><span class="o">=</span><span class="n">array</span><span class="o">.</span><span class="n">size</span><span class="p">,</span>
                <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ufunc</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_all</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_ufunc_logical_skipna</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">ufunc</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_any</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_ufunc_logical_skipna</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">ufunc</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_nanall</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_ufunc_logical_skipna</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">ufunc</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_nanany</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_ufunc_logical_skipna</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">ufunc</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>


<span class="c1"># TODO: specify the out dtype of these functions for bool</span>
<span class="n">_UFUNC_AXIS_SKIPNA</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;all&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">_all</span><span class="p">,</span> <span class="n">_nanall</span><span class="p">,</span> <span class="nb">bool</span><span class="p">),</span>
        <span class="s1">&#39;any&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">_any</span><span class="p">,</span> <span class="n">_nanany</span><span class="p">,</span> <span class="nb">bool</span><span class="p">),</span>
        <span class="s1">&#39;sum&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
        <span class="s1">&#39;min&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
        <span class="s1">&#39;max&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
        <span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
        <span class="s1">&#39;std&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
        <span class="s1">&#39;var&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nanvar</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
        <span class="s1">&#39;prod&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nanprod</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
        <span class="s1">&#39;cumsum&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nancumsum</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
        <span class="s1">&#39;cumprod&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nancumprod</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="p">}</span>

<span class="k">class</span> <span class="nc">MetaOperatorDelegate</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Auto-populate binary and unary methods based on instance methods named `_ufunc_unary_operator` and `_ufunc_binary_operator`.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">create_ufunc_operator</span><span class="p">(</span><span class="n">func_name</span><span class="p">,</span> <span class="n">opperand_count</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># operator module defines alias to funcs with names like __add__, etc</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">reverse</span><span class="p">:</span>
            <span class="n">operator_func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">operator_mod</span><span class="p">,</span> <span class="n">func_name</span><span class="p">)</span>
            <span class="n">func_wrapper</span> <span class="o">=</span> <span class="n">operator_func</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">unreversed_operator_func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">operator_mod</span><span class="p">,</span> <span class="n">_REVERSE_OPERATOR_MAP</span><span class="p">[</span><span class="n">func_name</span><span class="p">])</span>
            <span class="c1"># flip the order of the arguments</span>
            <span class="n">operator_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">lhs</span><span class="p">:</span> <span class="n">unreversed_operator_func</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
            <span class="n">func_wrapper</span> <span class="o">=</span> <span class="n">unreversed_operator_func</span>

        <span class="k">if</span> <span class="n">opperand_count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">reverse</span> <span class="c1"># cannot reverse a single opperand</span>
            <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ufunc_unary_operator</span><span class="p">(</span><span class="n">operator_func</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">opperand_count</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ufunc_binary_operator</span><span class="p">(</span><span class="n">operator</span><span class="o">=</span><span class="n">operator_func</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

        <span class="n">f</span> <span class="o">=</span> <span class="n">wraps</span><span class="p">(</span><span class="n">func_wrapper</span><span class="p">)(</span><span class="n">func</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">func_name</span>
        <span class="k">return</span> <span class="n">f</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">create_ufunc_axis_skipna</span><span class="p">(</span><span class="n">func_name</span><span class="p">):</span>
        <span class="n">ufunc</span><span class="p">,</span> <span class="n">ufunc_skipna</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">_UFUNC_AXIS_SKIPNA</span><span class="p">[</span><span class="n">func_name</span><span class="p">]</span>

        <span class="c1"># these become the common defaults for all of these functions</span>
        <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ufunc_axis_skipna</span><span class="p">(</span>
                    <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                    <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span>
                    <span class="n">ufunc</span><span class="o">=</span><span class="n">ufunc</span><span class="p">,</span>
                    <span class="n">ufunc_skipna</span><span class="o">=</span><span class="n">ufunc_skipna</span><span class="p">,</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">f</span> <span class="o">=</span> <span class="n">wraps</span><span class="p">(</span><span class="n">ufunc</span><span class="p">)(</span><span class="n">func</span><span class="p">)</span> <span class="c1"># not sure if this is correct</span>
        <span class="n">f</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">func_name</span>
        <span class="k">return</span> <span class="n">f</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Create and assign all autopopulated functions.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">opperand_count</span><span class="p">,</span> <span class="n">func_name</span> <span class="ow">in</span> <span class="n">chain</span><span class="p">(</span>
                <span class="n">product</span><span class="p">((</span><span class="mi">1</span><span class="p">,),</span> <span class="n">_UFUNC_UNARY_OPERATORS</span><span class="p">),</span>
                <span class="n">product</span><span class="p">((</span><span class="mi">2</span><span class="p">,),</span> <span class="n">_UFUNC_BINARY_OPERATORS</span><span class="p">)):</span>
            <span class="n">attrs</span><span class="p">[</span><span class="n">func_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">mcs</span><span class="o">.</span><span class="n">create_ufunc_operator</span><span class="p">(</span>
                    <span class="n">func_name</span><span class="p">,</span>
                    <span class="n">opperand_count</span><span class="o">=</span><span class="n">opperand_count</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">func_name</span> <span class="ow">in</span> <span class="n">_REVERSE_OPERATOR_MAP</span><span class="p">:</span>
            <span class="n">attrs</span><span class="p">[</span><span class="n">func_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">mcs</span><span class="o">.</span><span class="n">create_ufunc_operator</span><span class="p">(</span>
                    <span class="n">func_name</span><span class="p">,</span>
                    <span class="n">opperand_count</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                    <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">func_name</span> <span class="ow">in</span> <span class="n">_UFUNC_AXIS_SKIPNA</span><span class="p">:</span>
            <span class="n">attrs</span><span class="p">[</span><span class="n">func_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">mcs</span><span class="o">.</span><span class="n">create_ufunc_axis_skipna</span><span class="p">(</span><span class="n">func_name</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">type</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>

<span class="c1">#-------------------------------------------------------------------------------</span>
<span class="c1"># utility</span>

<span class="c1"># for getitem / loc selection</span>
<span class="n">_KEY_ITERABLE_TYPES</span> <span class="o">=</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>

<span class="c1"># types of keys that return muultiple items, even if the selection reduces to 1</span>
<span class="n">_KEY_MULTIPLE_TYPES</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>

<span class="c1"># for type hinting</span>
<span class="c1"># keys once dimension has been isolated</span>
<span class="n">GetItemKeyType</span> <span class="o">=</span> <span class="n">tp</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">slice</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
<span class="c1"># keys that might include a multiple dimensions speciation; tuple is used to identify compound extraction</span>
<span class="n">GetItemKeyTypeCompound</span> <span class="o">=</span> <span class="n">tp</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">slice</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>

<span class="n">CallableOrMapping</span> <span class="o">=</span> <span class="n">tp</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="n">tp</span><span class="o">.</span><span class="n">Callable</span><span class="p">,</span> <span class="n">tp</span><span class="o">.</span><span class="n">Mapping</span><span class="p">]</span>
<span class="n">KeyOrKeys</span> <span class="o">=</span> <span class="n">tp</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="n">tp</span><span class="o">.</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">tp</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="n">tp</span><span class="o">.</span><span class="n">Hashable</span><span class="p">]]</span>
<span class="n">FilePathOrFileLike</span> <span class="o">=</span> <span class="n">tp</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">StringIO</span><span class="p">,</span> <span class="n">BytesIO</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">mloc</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;Return the memory location of an array.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">array</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_gen_skip_middle</span><span class="p">(</span>
        <span class="n">forward_iter</span><span class="p">,</span>
        <span class="n">forward_count</span><span class="p">,</span>
        <span class="n">reverse_iter</span><span class="p">,</span>
        <span class="n">reverse_count</span><span class="p">,</span>
        <span class="n">center_sentinel</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Provide a generator to yield the count values from each side.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># for the forward gen, we take one more column to serve as the center column ellipsis; thus, we start enumeration at 0</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">forward_iter</span><span class="p">(),</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">value</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="n">forward_count</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="c1"># center sentinel</span>
    <span class="k">yield</span> <span class="n">center_sentinel</span>

    <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">reverse_iter</span><span class="p">(),</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="n">reverse_count</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="k">yield from</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_full_for_fill</span><span class="p">(</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">shape</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">tp</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
        <span class="n">fill_value</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Args:</span>
<span class="sd">        dtype: target dtype, which may or may not be possible given the fill_value.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">fill_can_cast</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span> <span class="c1"># happens when fill is None and dtype is float</span>
        <span class="n">fill_can_cast</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">object</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">fill_can_cast</span> <span class="k">else</span> <span class="n">dtype</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_resolve_dtype</span><span class="p">(</span><span class="n">dt1</span><span class="p">,</span> <span class="n">dt2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given two dtypes, return a compatible dtype that can hold both contents without truncation.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># NOTE: np.dtype(object) == np.object_, so we can return np.object_</span>
    <span class="c1"># if the same, return that detype</span>
    <span class="k">if</span> <span class="n">dt1</span> <span class="o">==</span> <span class="n">dt2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dt1</span>

    <span class="c1"># if either is object, we go to object</span>
    <span class="k">if</span> <span class="n">dt1</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;O&#39;</span> <span class="ow">or</span> <span class="n">dt2</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;O&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">object_</span>

    <span class="n">dt1_is_str</span> <span class="o">=</span> <span class="n">dt1</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="n">_DTYPE_STR_KIND</span>
    <span class="n">dt2_is_str</span> <span class="o">=</span> <span class="n">dt2</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="n">_DTYPE_STR_KIND</span>

    <span class="c1"># if both are string or string-lie, we can use result type to get the longest string</span>
    <span class="k">if</span> <span class="n">dt1_is_str</span> <span class="ow">and</span> <span class="n">dt2_is_str</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">dt1</span><span class="p">,</span> <span class="n">dt2</span><span class="p">)</span>

    <span class="n">dt1_is_bool</span> <span class="o">=</span> <span class="n">dt1</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span>
    <span class="n">dt2_is_bool</span> <span class="o">=</span> <span class="n">dt2</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span>

    <span class="c1"># if any one is a string or a bool, we have to go to object; result_type gives a string in mixed cases</span>
    <span class="k">if</span> <span class="n">dt1_is_str</span> <span class="ow">or</span> <span class="n">dt2_is_str</span> <span class="ow">or</span> <span class="n">dt1_is_bool</span> <span class="ow">or</span> <span class="n">dt2_is_bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">object_</span>

    <span class="c1"># if not a string or an object, can use result type</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">dt1</span><span class="p">,</span> <span class="n">dt2</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_resolve_dtype_iter</span><span class="p">(</span><span class="n">dtypes</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">]):</span>
    <span class="sd">&#39;&#39;&#39;Given an iterable of dtypes, do pairwise comparisons to determine compatible overall type. Once we get to object we can stop checking and return object</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">dtypes</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">dtypes</span><span class="p">)</span>
    <span class="n">dt_resolve</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">dtypes</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">dtypes</span><span class="p">:</span>
        <span class="n">dt_resolve</span> <span class="o">=</span> <span class="n">_resolve_dtype</span><span class="p">(</span><span class="n">dt_resolve</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dt_resolve</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">object_</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dt_resolve</span>
    <span class="k">return</span> <span class="n">dt_resolve</span>


<span class="k">def</span> <span class="nf">_dtype_to_na</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Given a dtype, return an appropriate and compatible null value.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
        <span class="c1"># we permit things like object, float, etc.</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="n">_DTYPE_INT_KIND</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span> <span class="c1"># cannot support NaN</span>
    <span class="k">elif</span> <span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">elif</span> <span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">elif</span> <span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;O&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="n">_DTYPE_STR_KIND</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;&#39;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;no support for this dtype&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">.</span><span class="n">kind</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_ufunc_skipna_1d</span><span class="p">(</span><span class="o">*</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">skipna</span><span class="p">,</span> <span class="n">ufunc</span><span class="p">,</span> <span class="n">ufunc_skipna</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;For one dimensional ufunc array application. Expected to always reduce to single element.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># if len(array) == 0:</span>
    <span class="c1">#     # np returns 0 for sum of an empty array</span>
    <span class="c1">#     return 0.0</span>
    <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;O&#39;</span><span class="p">:</span>
        <span class="c1"># replace None with nan</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">not_equal</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># all values were None</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">array</span>
    <span class="k">if</span> <span class="n">skipna</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ufunc_skipna</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ufunc</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_iterable_to_array</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tp</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]:</span>
    <span class="sd">&#39;&#39;&#39;Utility method to take arbitary, heterogenous typed iterables and realize them as an NP array. As this is used in isin() functions, identifying cases where we can assume that this array has only unique values is useful. That is done here by type, where Set-like types are marked as assume_unique.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">v_iter</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">other</span> <span class="c1"># not making this immutable; clients can decide</span>
        <span class="c1"># could look if unique, not sure if too much overhead</span>
        <span class="n">assume_unique</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">else</span><span class="p">:</span> <span class="c1"># must determine if we need an object type</span>
        <span class="c1"># we can use assume_unique if `other` is a set, keys view, frozen set, another index, as our _labels is always unique</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">Set</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)):</span> <span class="c1"># mathches set, frozenset, keysview</span>
            <span class="n">v_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="n">assume_unique</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># generators and other iteraables, lists, etc</span>
            <span class="n">v_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="n">assume_unique</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># must determine if we have heterogenous types, as if we have string and float, for example, all numbers become quoted</span>
        <span class="n">x</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">v_iter</span><span class="p">)</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">array_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">v_iter</span><span class="p">:</span>
            <span class="n">array_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="c1"># if it is not the same as previous, return object</span>
            <span class="k">if</span> <span class="n">dtype</span> <span class="o">!=</span> <span class="nb">object</span> <span class="ow">and</span> <span class="n">dtype</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="nb">object</span>

        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">array_values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">v</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">assume_unique</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="n">v</span><span class="p">,</span> <span class="n">assume_unique</span>


<span class="k">def</span> <span class="nf">_array_to_groups_and_locations</span><span class="p">(</span>
        <span class="n">array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">unique_axis</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Locations are index positions for each group.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">groups</span><span class="p">,</span> <span class="n">locations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
                <span class="n">array</span><span class="p">,</span>
                <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">axis</span><span class="o">=</span><span class="n">unique_axis</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="c1"># group by string representations, necessary when types are not comparable</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">group_index</span><span class="p">,</span> <span class="n">locations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
                <span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">),</span>
                <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">axis</span><span class="o">=</span><span class="n">unique_axis</span><span class="p">)</span>
        <span class="c1"># groups here are the strings; need to restore to values</span>
        <span class="n">groups</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">group_index</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">groups</span><span class="p">,</span> <span class="n">locations</span>

<span class="k">def</span> <span class="nf">_isna</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;Utility function that, given an np.ndarray, returns a bolean arrea setting True nulls. Note: the returned array is not made immutable</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># TODO: this function is a bottleneck: perhaps use numba?</span>
    <span class="c1"># moatches all floating point types</span>
    <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="c1"># match everything that is not an object; options are: biufcmMOSUV</span>
    <span class="k">elif</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">!=</span> <span class="s1">&#39;O&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="c1"># only check for None if we have an object type</span>
    <span class="c1"># astype: None gets converted to nan if possible</span>
    <span class="k">try</span><span class="p">:</span> <span class="c1"># this will only work for arrays that do not have strings</span>
        <span class="c1"># cannot use can_cast to reliabily identify arrays with non-float-castable elements</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">))</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="c1"># this means there was a character or something not castable to float; have to prceed slowly</span>
        <span class="c1"># TODO: this is a big perforamnce hit; problem is cannot find np.nan in numpy object array</span>
        <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">((</span><span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">x</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">array</span><span class="p">),</span>
                    <span class="n">count</span><span class="o">=</span><span class="n">array</span><span class="o">.</span><span class="n">size</span><span class="p">,</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">((</span><span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">x</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">array</span><span class="o">.</span><span class="n">flat</span><span class="p">),</span>
                <span class="n">count</span><span class="o">=</span><span class="n">array</span><span class="o">.</span><span class="n">size</span><span class="p">,</span>
                <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_array_to_duplicated</span><span class="p">(</span>
        <span class="n">array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">exclude_first</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">exclude_last</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Given a numpy array, return a Boolean array along the specified axis that shows which values are duplicated. By default, all duplicates are indicated. For 2d arrays, axis 0 compares rows and returns a row-length Boolean array; axis 1 compares  colimns and returns a column-length Boolean array.</span>

<span class="sd">    Args:</span>
<span class="sd">        exclude_first: Mark as True all duplicates except the first encountared.</span>
<span class="sd">        exclude_last: Mark as True all duplicates except the last encountared.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># based in part on https://stackoverflow.com/questions/11528078/determining-duplicate-values-in-an-array</span>
    <span class="c1"># https://stackoverflow.com/a/43033882/388739</span>
    <span class="c1"># indices to sort and sorted array</span>
    <span class="c1"># a right roll on the sorted array, comparing to the original sorted array. creates a boolean array, with all non-first duplicates marked as True</span>

    <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">o_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">_DEFAULT_STABLE_SORT_KIND</span><span class="p">)</span>
        <span class="n">array_sorted</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">o_idx</span><span class="p">]</span>
        <span class="n">opposite_axis</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">f_flags</span> <span class="o">=</span> <span class="n">array_sorted</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">array_sorted</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># sort rows</span>
            <span class="c1"># first should be last</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="p">[</span><span class="n">array</span><span class="p">[:,</span> <span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
            <span class="n">o_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="n">array_sorted</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">o_idx</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># sort columns</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="p">[</span><span class="n">array</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
            <span class="n">o_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="n">array_sorted</span> <span class="o">=</span> <span class="n">array</span><span class="p">[:,</span> <span class="n">o_idx</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;no handling for axis&#39;</span><span class="p">)</span>
        <span class="n">opposite_axis</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="ow">not</span> <span class="nb">bool</span><span class="p">(</span><span class="n">axis</span><span class="p">))</span>
        <span class="c1"># rolling axis 1 rotates columns; roll axis 0 rotates rows</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">array_sorted</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">array_sorted</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">f_flags</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">opposite_axis</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">f_flags</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="c1"># we always return a 1 dim array</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">f_flags</span><span class="p">),</span> <span class="kc">False</span><span class="p">)</span>

    <span class="c1"># The first element of f_flags should always be False.</span>
    <span class="c1"># In certain edge cases, this doesn&#39;t happen naturally.</span>
    <span class="c1"># Index 0 should always exist, due to `.any()` behavior.</span>
    <span class="n">f_flags</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">False_</span>

    <span class="k">if</span> <span class="n">exclude_first</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">exclude_last</span><span class="p">:</span>
        <span class="n">dupes</span> <span class="o">=</span> <span class="n">f_flags</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># non-LAST duplicates is a left roll of the non-first flags.</span>
        <span class="n">l_flags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">f_flags</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">exclude_first</span> <span class="ow">and</span> <span class="n">exclude_last</span><span class="p">:</span>
            <span class="n">dupes</span> <span class="o">=</span> <span class="n">l_flags</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">exclude_first</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">exclude_last</span><span class="p">:</span>
            <span class="c1"># all duplicates is the union.</span>
            <span class="n">dupes</span> <span class="o">=</span> <span class="n">f_flags</span> <span class="o">|</span> <span class="n">l_flags</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># all non-first, non-last duplicates is the intersection.</span>
            <span class="n">dupes</span> <span class="o">=</span> <span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">l_flags</span>

    <span class="c1"># undo the sort: get the indices to extract Booleans from dupes; in some cases r_idx is the same as o_idx, but not all</span>
    <span class="n">r_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">o_idx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">_DEFAULT_STABLE_SORT_KIND</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dupes</span><span class="p">[</span><span class="n">r_idx</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_array_set_ufunc_many</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">ufunc</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Iteratively apply a set operation unfunc to a arrays; if all are equal, no operation is performed and order is retained.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">arrays</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">array</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">:</span>
        <span class="c1"># is the new array different</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">array</span> <span class="o">!=</span> <span class="n">result</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">ufunc</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">array</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ufunc</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># short circuit intersection</span>
            <span class="k">return</span> <span class="n">result</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="c1">#-------------------------------------------------------------------------------</span>

<span class="k">class</span> <span class="nc">GetItem</span><span class="p">:</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;callback&#39;</span><span class="p">,)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callback</span> <span class="o">=</span> <span class="n">callback</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">GetItemKeyType</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">callback</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ExtractInterface</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;An instance to serve as an interface to all of iloc, loc, and __getitem__ extractors.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;iloc&#39;</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="s1">&#39;getitem&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
            <span class="n">iloc</span><span class="p">:</span> <span class="n">GetItem</span><span class="p">,</span>
            <span class="n">loc</span><span class="p">:</span> <span class="n">GetItem</span><span class="p">,</span>
            <span class="n">getitem</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Callable</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span> <span class="o">=</span> <span class="n">iloc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loc</span> <span class="o">=</span> <span class="n">loc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">getitem</span> <span class="o">=</span> <span class="n">getitem</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getitem</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>



<span class="c1">#-------------------------------------------------------------------------------</span>
<span class="c1"># display infrastructure</span>

<span class="k">class</span> <span class="nc">DisplayConfig</span><span class="p">:</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s1">&#39;type_show&#39;</span><span class="p">,</span>
        <span class="s1">&#39;type_color&#39;</span><span class="p">,</span>
        <span class="s1">&#39;type_delimiter&#39;</span><span class="p">,</span>
        <span class="s1">&#39;display_columns&#39;</span><span class="p">,</span>
        <span class="s1">&#39;display_rows&#39;</span><span class="p">,</span>
        <span class="s1">&#39;cell_max_width&#39;</span><span class="p">,</span>
        <span class="s1">&#39;cell_align_left&#39;</span>
        <span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_json</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DisplaysConfig&#39;</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="nb">str</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="n">args</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">fp</span><span class="p">):</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fp</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Write a JSON file.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_json</span><span class="p">()</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_default</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">type_show</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">type_color</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">type_delimiter</span><span class="o">=</span><span class="s1">&#39;&lt;&gt;&#39;</span><span class="p">,</span>
            <span class="n">display_columns</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span>
            <span class="n">display_rows</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span><span class="o">=</span><span class="mi">36</span><span class="p">,</span>
            <span class="n">cell_max_width</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
            <span class="n">cell_align_left</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type_show</span> <span class="o">=</span> <span class="n">type_show</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type_color</span> <span class="o">=</span> <span class="n">type_color</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type_delimiter</span> <span class="o">=</span> <span class="n">type_delimiter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display_columns</span> <span class="o">=</span> <span class="n">display_columns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display_rows</span> <span class="o">=</span> <span class="n">display_rows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cell_max_width</span> <span class="o">=</span> <span class="n">cell_max_width</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cell_align_left</span> <span class="o">=</span> <span class="n">cell_align_left</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="s1">&#39;</span><span class="si">{k}</span><span class="s1">=</span><span class="si">{v}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__slots__</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;&gt;&#39;</span>

    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__slots__</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()))</span>

    <span class="k">def</span> <span class="nf">to_transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DisplayConfig&#39;</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
        <span class="n">args</span><span class="p">[</span><span class="s1">&#39;display_columns&#39;</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="s1">&#39;display_rows&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">args</span><span class="p">[</span><span class="s1">&#39;display_rows&#39;</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="s1">&#39;display_columns&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">**</span><span class="n">args</span><span class="p">)</span>


<span class="n">_module</span><span class="o">.</span><span class="n">_display_active</span> <span class="o">=</span> <span class="n">DisplayConfig</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">DisplayActive</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;Utility interface for setting module-level display configuration.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">FILE_NAME</span> <span class="o">=</span> <span class="s1">&#39;.static_frame.conf&#39;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="n">dc</span><span class="p">:</span> <span class="n">DisplayConfig</span><span class="p">):</span>
        <span class="n">_module</span><span class="o">.</span><span class="n">_display_active</span> <span class="o">=</span> <span class="n">dc</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">_module</span><span class="o">.</span><span class="n">_display_active</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">get</span><span class="p">()</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
        <span class="n">args</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">DisplayConfig</span><span class="p">(</span><span class="o">**</span><span class="n">args</span><span class="p">))</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_default_fp</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s1">&#39;~&#39;</span><span class="p">),</span> <span class="bp">cls</span><span class="o">.</span><span class="n">FILE_NAME</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">fp</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">fp</span> <span class="o">=</span> <span class="n">fp</span> <span class="ow">or</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_default_fp</span><span class="p">()</span>
        <span class="n">dc</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="n">dc</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">fp</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">fp</span> <span class="o">=</span> <span class="n">fp</span> <span class="ow">or</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_default_fp</span><span class="p">()</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">DisplayConfig</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">fp</span><span class="p">))</span>



<span class="k">class</span> <span class="nc">Display</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A Display is a string representation of a table, encoded as a list of lists, where list components are equal-width strings, keyed by row index</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;_rows&#39;</span><span class="p">,</span> <span class="s1">&#39;_config&#39;</span><span class="p">)</span>

    <span class="n">CHAR_MARGIN</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">CELL_EMPTY</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">ELLIPSIS</span> <span class="o">=</span> <span class="s1">&#39;...&#39;</span>
    <span class="n">CELL_ELLIPSIS</span> <span class="o">=</span> <span class="p">(</span><span class="n">ELLIPSIS</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ELLIPSIS</span><span class="p">))</span>
    <span class="n">ELLIPSIS_INDICES</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span>
    <span class="n">DATA_MARGINS</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1"># columns / rows that seperate data</span>
    <span class="n">ELLIPSIS_CENTER_SENTINEL</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">type_delimiter</span><span class="p">(</span><span class="n">dtype</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">config</span><span class="p">:</span> <span class="n">DisplayConfig</span><span class="p">):</span>
        <span class="n">dtype_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="k">else</span> <span class="n">dtype</span>
        <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">type_delimiter</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">config</span><span class="o">.</span><span class="n">type_delimiter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dtype_str</span> <span class="o">+</span> <span class="n">config</span><span class="o">.</span><span class="n">type_delimiter</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">dtype_str</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">type_color</span><span class="p">(</span><span class="n">dtype</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
        <span class="n">dtype_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="k">else</span> <span class="n">dtype</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\033</span><span class="s1">[90m&#39;</span> <span class="o">+</span> <span class="n">dtype_str</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\033</span><span class="s1">[0m&#39;</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">to_cell</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span>
            <span class="n">value</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Any</span><span class="p">,</span>
            <span class="n">config</span><span class="p">:</span> <span class="n">DisplayConfig</span><span class="p">,</span>
            <span class="n">is_dtype</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tp</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>

        <span class="k">if</span> <span class="n">is_dtype</span><span class="p">:</span>
            <span class="n">type_str</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">type_delimiter</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="n">config</span><span class="p">)</span>
            <span class="n">type_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">type_str</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">type_color</span><span class="p">:</span>
                <span class="n">type_str</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">type_color</span><span class="p">(</span><span class="n">type_str</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">type_str</span><span class="p">,</span> <span class="n">type_length</span><span class="p">)</span>

        <span class="n">msg</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_values</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span>
            <span class="n">values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
            <span class="n">header</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">config</span><span class="p">:</span> <span class="n">DisplayConfig</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Display&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Given a 1 or 2D ndarray, return a Display instance. Generally 2D arrays are passed here only from TypeBlocks.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># return a list of lists, where each inner list represents multiple columns</span>
        <span class="n">config</span> <span class="o">=</span> <span class="n">config</span> <span class="ow">or</span> <span class="n">DisplayActive</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>

        <span class="n">msg</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

        <span class="c1"># create a list of lists, always starting with the header</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="p">[[(</span><span class="n">msg</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">msg</span><span class="p">))]]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">values</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># get rows from numpy string formatting</span>
            <span class="n">np_rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_str</span><span class="p">(</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">last_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np_rows</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np_rows</span><span class="p">):</span>
                <span class="c1"># trim brackets</span>
                <span class="n">end_slice_len</span> <span class="o">=</span> <span class="mi">2</span> <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="n">last_idx</span> <span class="k">else</span> <span class="mi">1</span>
                <span class="n">row</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="o">-</span> <span class="n">end_slice_len</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="bp">cls</span><span class="o">.</span><span class="n">to_cell</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="n">config</span><span class="p">)])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">count_max</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">display_rows</span> <span class="o">-</span> <span class="bp">cls</span><span class="o">.</span><span class="n">DATA_MARGINS</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">count_max</span><span class="p">:</span>
                <span class="n">data_half_count</span> <span class="o">=</span> <span class="n">Display</span><span class="o">.</span><span class="n">truncate_half_count</span><span class="p">(</span><span class="n">count_max</span><span class="p">)</span>
                <span class="n">value_gen</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_gen_skip_middle</span><span class="p">,</span>
                        <span class="n">forward_iter</span><span class="o">=</span><span class="n">values</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">,</span>
                        <span class="n">forward_count</span><span class="o">=</span><span class="n">data_half_count</span><span class="p">,</span>
                        <span class="n">reverse_iter</span><span class="o">=</span><span class="n">partial</span><span class="p">(</span><span class="nb">reversed</span><span class="p">,</span> <span class="n">values</span><span class="p">),</span>
                        <span class="n">reverse_count</span><span class="o">=</span><span class="n">data_half_count</span><span class="p">,</span>
                        <span class="n">center_sentinel</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">ELLIPSIS_CENTER_SENTINEL</span>
                        <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">value_gen</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="fm">__iter__</span>

            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">value_gen</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="bp">cls</span><span class="o">.</span><span class="n">ELLIPSIS_CENTER_SENTINEL</span><span class="p">:</span> <span class="c1"># center sentinel</span>
                    <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="bp">cls</span><span class="o">.</span><span class="n">CELL_ELLIPSIS</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="bp">cls</span><span class="o">.</span><span class="n">to_cell</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="n">config</span><span class="p">)])</span>

        <span class="c1"># add the types to the last row</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">config</span><span class="o">.</span><span class="n">type_show</span><span class="p">:</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="bp">cls</span><span class="o">.</span><span class="n">to_cell</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="n">config</span><span class="p">,</span> <span class="n">is_dtype</span><span class="o">=</span><span class="kc">True</span><span class="p">)])</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># this is an object</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="bp">cls</span><span class="o">.</span><span class="n">CELL_EMPTY</span><span class="p">])</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="n">config</span><span class="p">)</span>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">truncate_half_count</span><span class="p">(</span><span class="n">count_target</span><span class="p">):</span>
        <span class="c1"># the total number returned will always be odd</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">count_target</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_truncate_indices</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">count_target</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>

        <span class="c1"># if have 5 data cols, 7 total, and target was 6</span>
        <span class="c1"># half count of 2, 5 total out, with 1 meta, 1 data, elipsis, data, meta</span>

        <span class="c1"># if have 5 data cols, 7 total, and target was 7</span>
        <span class="c1"># half count of 3, 7 total out, with 1 meta, 2 data, elipsis, 2 data, 1 meta</span>

        <span class="c1"># if have 6 data cols, 8 total, and target was 6</span>
        <span class="c1"># half count of 2, 5 total out, with 1 meta, 1 data, elipsis, data, meta</span>

        <span class="c1"># if have 6 data cols, 8 total, and target was 7</span>
        <span class="c1"># half count of 3, 7 total out, with 1 meta, 2 data, elipsis, 2 data, 1 meta</span>

        <span class="k">if</span> <span class="n">count_target</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">count_target</span><span class="p">:</span>
            <span class="n">half_count</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">truncate_half_count</span><span class="p">(</span><span class="n">count_target</span><span class="p">)</span>
            <span class="c1"># replace with array from_iter? with known size?</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span>
                    <span class="n">indices</span><span class="p">[:</span><span class="n">half_count</span><span class="p">],</span>
                    <span class="bp">cls</span><span class="o">.</span><span class="n">ELLIPSIS_INDICES</span><span class="p">,</span>
                    <span class="n">indices</span><span class="p">[</span><span class="o">-</span><span class="n">half_count</span><span class="p">:]))</span>
        <span class="k">return</span> <span class="n">indices</span>

    <span class="c1"># @classmethod</span>
    <span class="c1"># def _to_rows(cls, display: &#39;Display&#39;, config: DisplayConfig=None) -&gt; tp.Iterable[str]:</span>
    <span class="c1">#     &#39;&#39;&#39;</span>
    <span class="c1">#     Given already defined rows, align them to left or right.</span>
    <span class="c1">#     &#39;&#39;&#39;</span>
    <span class="c1">#     config = config or DisplayActive.get()</span>

    <span class="c1">#     # find max columns for all defined rows</span>
    <span class="c1">#     col_count_src = max(len(row) for row in display._rows)</span>
    <span class="c1">#     col_last_src = col_count_src - 1</span>
    <span class="c1">#     col_indices_src = tuple(range(col_count_src))</span>
    <span class="c1">#     col_indices = cls._truncate_indices(config.display_columns, col_indices_src)</span>

    <span class="c1">#     row_count_src = len(display._rows)</span>
    <span class="c1">#     row_indices_src = tuple(range(row_count_src))</span>
    <span class="c1">#     row_indices = cls._truncate_indices(config.display_rows, row_indices_src)</span>

    <span class="c1">#     rows = [[] for _ in row_indices]</span>

    <span class="c1">#     for col_idx_dst, col_idx_src in enumerate(col_indices):</span>
    <span class="c1">#         # for each column, get the max width</span>
    <span class="c1">#         if col_idx_src is None:</span>
    <span class="c1">#             max_width = len(cls.ELLIPSIS)</span>
    <span class="c1">#         else:</span>
    <span class="c1">#             max_width = 0</span>
    <span class="c1">#             for row_idx_src in row_indices:</span>
    <span class="c1">#                 # get existing max width, up to the max</span>
    <span class="c1">#                 if row_idx_src is not None:</span>
    <span class="c1">#                     row = display._rows[row_idx_src]</span>
    <span class="c1">#                     if col_idx_src &gt;= len(row): # this row does not have this column</span>
    <span class="c1">#                         continue</span>
    <span class="c1">#                     cell = row[col_idx_src]</span>

    <span class="c1">#                     max_width = max(max_width, cell[1])</span>
    <span class="c1">#                 else:</span>
    <span class="c1">#                     max_width = max(max_width, len(cls.ELLIPSIS))</span>
    <span class="c1">#                 # if we have already exceeded max width, can stop iterating</span>
    <span class="c1">#                 if max_width &gt;= config.cell_max_width:</span>
    <span class="c1">#                     break</span>
    <span class="c1">#             max_width = min(max_width, config.cell_max_width)</span>

    <span class="c1">#         if ((config.cell_align_left is True and col_idx_src == col_last_src) or</span>
    <span class="c1">#                 (config.cell_align_left is False and col_idx_src == 0)):</span>
    <span class="c1">#             pad_width = max_width</span>
    <span class="c1">#         else:</span>
    <span class="c1">#             pad_width = max_width + cls.CHAR_MARGIN</span>

    <span class="c1">#         for row_idx_dst, row_idx_src in enumerate(row_indices):</span>
    <span class="c1">#             if row_idx_src is None or col_idx_src is None:</span>
    <span class="c1">#                 cell = cls.CELL_ELLIPSIS</span>
    <span class="c1">#             else:</span>
    <span class="c1">#                 row = display._rows[row_idx_src]</span>
    <span class="c1">#                 if col_idx_src &gt;= len(row):</span>
    <span class="c1">#                     cell = cls.CELL_EMPTY</span>
    <span class="c1">#                 else:</span>
    <span class="c1">#                     cell = row[col_idx_src]</span>
    <span class="c1">#             # msg may have been ljusted before, so we strip again here</span>
    <span class="c1">#             # cannot use ljust here, as the cell might have more characters for coloring</span>
    <span class="c1">#             if cell[1] &gt; max_width:</span>
    <span class="c1">#                 cell_content = cell[0].strip()[:max_width - 3] + cls.ELLIPSIS</span>
    <span class="c1">#                 cell_fill_width = cls.CHAR_MARGIN # should only be margin left</span>
    <span class="c1">#             else:</span>
    <span class="c1">#                 cell_content = cell[0].strip()</span>
    <span class="c1">#                 cell_fill_width = pad_width - cell[1] # this includes margin</span>

    <span class="c1">#             # print(col_idx, row_idx, cell, max_width, pad_width, cell_fill_width)</span>
    <span class="c1">#             if config.cell_align_left:</span>
    <span class="c1">#                 # must manually add space as color chars make ljust not</span>
    <span class="c1">#                 msg = cell_content + &#39; &#39; * cell_fill_width</span>
    <span class="c1">#             else:</span>
    <span class="c1">#                 msg =  &#39; &#39; * cell_fill_width + cell_content</span>

    <span class="c1">#             rows[row_idx_dst].append(msg)</span>

    <span class="c1">#     return [&#39;&#39;.join(row) for row in rows]</span>




    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_to_rows</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">display</span><span class="p">:</span> <span class="s1">&#39;Display&#39;</span><span class="p">,</span> <span class="n">config</span><span class="p">:</span> <span class="n">DisplayConfig</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tp</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Given already defined rows, align them to left or right.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">config</span> <span class="o">=</span> <span class="n">config</span> <span class="ow">or</span> <span class="n">DisplayActive</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>

        <span class="c1"># find max columns for all defined rows</span>
        <span class="n">col_count_src</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">display</span><span class="o">.</span><span class="n">_rows</span><span class="p">)</span>
        <span class="n">col_last_src</span> <span class="o">=</span> <span class="n">col_count_src</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="n">row_count_src</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">display</span><span class="o">.</span><span class="n">_rows</span><span class="p">)</span>
        <span class="n">row_indices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">row_count_src</span><span class="p">))</span>

        <span class="n">rows</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">row_indices</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">col_idx_src</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">col_count_src</span><span class="p">):</span>
            <span class="c1"># for each column, get the max width</span>
            <span class="n">max_width</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">row_idx_src</span> <span class="ow">in</span> <span class="n">row_indices</span><span class="p">:</span>
                <span class="c1"># get existing max width, up to the max</span>
                <span class="k">if</span> <span class="n">row_idx_src</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">row</span> <span class="o">=</span> <span class="n">display</span><span class="o">.</span><span class="n">_rows</span><span class="p">[</span><span class="n">row_idx_src</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">col_idx_src</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">):</span> <span class="c1"># this row does not have this column</span>
                        <span class="k">continue</span>
                    <span class="n">cell</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">col_idx_src</span><span class="p">]</span>

                    <span class="n">max_width</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_width</span><span class="p">,</span> <span class="n">cell</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">max_width</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_width</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">ELLIPSIS</span><span class="p">))</span>
                <span class="c1"># if we have already exceeded max width, can stop iterating</span>
                <span class="k">if</span> <span class="n">max_width</span> <span class="o">&gt;=</span> <span class="n">config</span><span class="o">.</span><span class="n">cell_max_width</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="n">max_width</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_width</span><span class="p">,</span> <span class="n">config</span><span class="o">.</span><span class="n">cell_max_width</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">((</span><span class="n">config</span><span class="o">.</span><span class="n">cell_align_left</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">col_idx_src</span> <span class="o">==</span> <span class="n">col_last_src</span><span class="p">)</span> <span class="ow">or</span>
                    <span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">cell_align_left</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">col_idx_src</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)):</span>
                <span class="n">pad_width</span> <span class="o">=</span> <span class="n">max_width</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pad_width</span> <span class="o">=</span> <span class="n">max_width</span> <span class="o">+</span> <span class="bp">cls</span><span class="o">.</span><span class="n">CHAR_MARGIN</span>

            <span class="k">for</span> <span class="n">row_idx_src</span> <span class="ow">in</span> <span class="n">row_indices</span><span class="p">:</span>
                <span class="n">row</span> <span class="o">=</span> <span class="n">display</span><span class="o">.</span><span class="n">_rows</span><span class="p">[</span><span class="n">row_idx_src</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">col_idx_src</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
                    <span class="n">cell</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">CELL_EMPTY</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cell</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">col_idx_src</span><span class="p">]</span>
                <span class="c1"># msg may have been ljusted before, so we strip again here</span>
                <span class="c1"># cannot use ljust here, as the cell might have more characters for coloring</span>
                <span class="k">if</span> <span class="n">cell</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max_width</span><span class="p">:</span>
                    <span class="n">cell_content</span> <span class="o">=</span> <span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()[:</span><span class="n">max_width</span> <span class="o">-</span> <span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="bp">cls</span><span class="o">.</span><span class="n">ELLIPSIS</span>
                    <span class="n">cell_fill_width</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">CHAR_MARGIN</span> <span class="c1"># should only be margin left</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cell_content</span> <span class="o">=</span> <span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                    <span class="n">cell_fill_width</span> <span class="o">=</span> <span class="n">pad_width</span> <span class="o">-</span> <span class="n">cell</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># this includes margin</span>

                <span class="c1"># print(col_idx, row_idx, cell, max_width, pad_width, cell_fill_width)</span>
                <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">cell_align_left</span><span class="p">:</span>
                    <span class="c1"># must manually add space as color chars make ljust not</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="n">cell_content</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="n">cell_fill_width</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span>  <span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="n">cell_fill_width</span> <span class="o">+</span> <span class="n">cell_content</span>

                <span class="n">rows</span><span class="p">[</span><span class="n">row_idx_src</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">]</span>




    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">rows</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">tp</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">tp</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]],</span>
            <span class="n">config</span><span class="p">:</span> <span class="n">DisplayConfig</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Define rows as a list of strings; the strings may be of different size, but they are expected to be aligned vertically in final presentation.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">config</span> <span class="o">=</span> <span class="n">config</span> <span class="ow">or</span> <span class="n">DisplayActive</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rows</span> <span class="o">=</span> <span class="n">rows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_config</span> <span class="o">=</span> <span class="n">config</span>


    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_to_rows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">to_rows</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tp</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_rows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rows</span><span class="p">:</span>
            <span class="k">yield</span> <span class="p">[</span><span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">row</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rows</span><span class="p">)</span>

    <span class="c1">#---------------------------------------------------------------------------</span>
    <span class="c1"># in place mutation</span>

    <span class="k">def</span> <span class="nf">append_display</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">display</span><span class="p">:</span> <span class="s1">&#39;Display&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Mutate this display by appending the passed display.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># NOTE: do not want to pass config or call format here as we call this for each column or block we add</span>
        <span class="k">for</span> <span class="n">row_idx</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">display</span><span class="o">.</span><span class="n">_rows</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rows</span><span class="p">[</span><span class="n">row_idx</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">append_iterable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">iterable</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="n">tp</span><span class="o">.</span><span class="n">Any</span><span class="p">],</span>
            <span class="n">header</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Add an iterable of strings</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rows</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_cell</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">))</span>

        <span class="c1"># truncate iterable if necessary</span>
        <span class="n">count_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="o">.</span><span class="n">display_rows</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">DATA_MARGINS</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">count_max</span><span class="p">:</span>
            <span class="n">data_half_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">truncate_half_count</span><span class="p">(</span><span class="n">count_max</span><span class="p">)</span>
            <span class="n">value_gen</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_gen_skip_middle</span><span class="p">,</span>
                    <span class="n">forward_iter</span> <span class="o">=</span> <span class="n">iterable</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">,</span>
                    <span class="n">forward_count</span> <span class="o">=</span> <span class="n">data_half_count</span><span class="p">,</span>
                    <span class="n">reverse_iter</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="nb">reversed</span><span class="p">,</span> <span class="n">iterable</span><span class="p">),</span>
                    <span class="n">reverse_count</span> <span class="o">=</span> <span class="n">data_half_count</span><span class="p">,</span>
                    <span class="n">center_sentinel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ELLIPSIS_CENTER_SENTINEL</span>
                    <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">value_gen</span> <span class="o">=</span> <span class="n">iterable</span><span class="o">.</span><span class="fm">__iter__</span>

        <span class="c1"># start at 1 as 0 is header</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">value_gen</span><span class="p">(),</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">ELLIPSIS_CENTER_SENTINEL</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_rows</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CELL_ELLIPSIS</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_rows</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_cell</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="o">.</span><span class="n">type_show</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_rows</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_cell</span><span class="p">(</span><span class="n">iterable</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                        <span class="n">config</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">,</span>
                        <span class="n">is_dtype</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">append_ellipsis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Append an ellipsis over all rows.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rows</span><span class="p">:</span>
            <span class="n">row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CELL_ELLIPSIS</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">insert_rows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">displays</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="s1">&#39;Display&#39;</span><span class="p">]):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Insert rows on top of existing rows.</span>
<span class="sd">        args:</span>
<span class="sd">            Each arg in args is an instance of Display</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># each arg is a list, to be a new row</span>
        <span class="c1"># assume each row in display becomes a column</span>
        <span class="n">new_rows</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">display</span> <span class="ow">in</span> <span class="n">displays</span><span class="p">:</span>
            <span class="n">new_rows</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">display</span><span class="o">.</span><span class="n">_rows</span><span class="p">)</span>
        <span class="c1"># slow for now: make rows a dict to make faster</span>
        <span class="n">new_rows</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rows</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rows</span> <span class="o">=</span> <span class="n">new_rows</span>

    <span class="c1">#---------------------------------------------------------------------------</span>
    <span class="c1"># return a new display</span>

    <span class="k">def</span> <span class="nf">flatten</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Display&#39;</span><span class="p">:</span>
        <span class="n">row</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rows</span><span class="p">:</span>
            <span class="n">row</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">part</span><span class="p">)</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="p">)</span>

<span class="c1">#-------------------------------------------------------------------------------</span>
<span class="k">class</span> <span class="nc">IndexCorrespondence</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    All iloc data necessary for reindexing.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s1">&#39;has_common&#39;</span><span class="p">,</span>
            <span class="s1">&#39;is_subset&#39;</span><span class="p">,</span>
            <span class="s1">&#39;iloc_src&#39;</span><span class="p">,</span>
            <span class="s1">&#39;iloc_dst&#39;</span><span class="p">,</span>
            <span class="s1">&#39;size&#39;</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_correspondence</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">src_index</span><span class="p">,</span> <span class="n">dst_index</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;IndexCorrespondence&#39;</span><span class="p">:</span>
        <span class="c1"># sorts results</span>
        <span class="n">common_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">src_index</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">dst_index</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="n">has_common</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_labels</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dst_index</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

        <span class="c1"># either a reordering or a subsetfrom_index</span>
        <span class="k">if</span> <span class="n">has_common</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_labels</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">dst_index</span><span class="p">):</span>
                <span class="c1"># use new index to retain order</span>
                <span class="n">iloc_src</span> <span class="o">=</span> <span class="n">src_index</span><span class="o">.</span><span class="n">loc_to_iloc</span><span class="p">(</span><span class="n">dst_index</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
                <span class="n">iloc_dst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">has_common</span><span class="o">=</span><span class="n">has_common</span><span class="p">,</span>
                        <span class="n">is_subset</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">iloc_src</span><span class="o">=</span><span class="n">iloc_src</span><span class="p">,</span>
                        <span class="n">iloc_dst</span><span class="o">=</span><span class="n">iloc_dst</span><span class="p">,</span>
                        <span class="n">size</span><span class="o">=</span><span class="n">size</span>
                        <span class="p">)</span>

            <span class="c1"># these will be equal sized; not sure if they will be in order</span>
            <span class="n">iloc_src</span> <span class="o">=</span> <span class="n">src_index</span><span class="o">.</span><span class="n">loc_to_iloc</span><span class="p">(</span><span class="n">common_labels</span><span class="p">)</span>
            <span class="n">iloc_dst</span> <span class="o">=</span> <span class="n">dst_index</span><span class="o">.</span><span class="n">loc_to_iloc</span><span class="p">(</span><span class="n">common_labels</span><span class="p">)</span>

            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">has_common</span><span class="o">=</span><span class="n">has_common</span><span class="p">,</span>
                    <span class="n">is_subset</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">iloc_src</span><span class="o">=</span><span class="n">iloc_src</span><span class="p">,</span>
                    <span class="n">iloc_dst</span><span class="o">=</span><span class="n">iloc_dst</span><span class="p">,</span>
                    <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">has_common</span><span class="o">=</span><span class="n">has_common</span><span class="p">,</span>
                <span class="n">is_subset</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">iloc_src</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">iloc_dst</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">has_common</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
            <span class="n">is_subset</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
            <span class="n">iloc_src</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
            <span class="n">iloc_dst</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
            <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Args:</span>
<span class="sd">            iloc_pairs: generate corresponding pairs of iloc postions between src and dst; may be empty or have less constituents than index.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">has_common</span> <span class="o">=</span> <span class="n">has_common</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_subset</span> <span class="o">=</span> <span class="n">is_subset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iloc_src</span> <span class="o">=</span> <span class="n">iloc_src</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iloc_dst</span> <span class="o">=</span> <span class="n">iloc_dst</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>

    <span class="k">def</span> <span class="nf">iloc_src_fancy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Convert an iloc iterable of integers into one that is combitable with fancy indexing.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="p">[[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloc_src</span><span class="p">]</span>



<span class="c1">#-------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="TypeBlocks"><a class="viewcode-back" href="../../../../overview.html#static_frame.TypeBlocks">[docs]</a><span class="k">class</span> <span class="nc">TypeBlocks</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">MetaOperatorDelegate</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;An ordered collection of potentially heterogenous, immutable NumPy arrays, providing an external array-like interface of a single, 2D array. Used by :py:class:`Frame` for core, unindexed array management.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># related to Pandas BlockManager</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s1">&#39;_blocks&#39;</span><span class="p">,</span>
            <span class="s1">&#39;_dtypes&#39;</span><span class="p">,</span>
            <span class="s1">&#39;_index&#39;</span><span class="p">,</span>
            <span class="s1">&#39;_shape&#39;</span><span class="p">,</span>
            <span class="s1">&#39;_row_dtype&#39;</span><span class="p">,</span>
            <span class="s1">&#39;iloc&#39;</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">immutable_filter</span><span class="p">(</span><span class="n">src_array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;Pass an immutable array; otherwise, return an immutable copy of the provided array.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">src_array</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span><span class="p">:</span>
            <span class="n">dst_array</span> <span class="o">=</span> <span class="n">src_array</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">dst_array</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="n">dst_array</span>
        <span class="k">return</span> <span class="n">src_array</span> <span class="c1"># keep it as is</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">single_column_filter</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;Reshape a flat ndim 1 array into a 2D array with one columns and rows of length. This is only used (a) for getting string representations and (b) for using np.concatenate and np binary operators on 1D arrays.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># it is not clear when reshape is a copy or a view</span>
        <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">array</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">shape_filter</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tp</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&#39;&#39;&#39;Reprsent a 1D array as a 2D array with length as rows of a single-column array.</span>

<span class="sd">        Return:</span>
<span class="sd">            row, column count for a block of ndim 1 or ndim 2.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1">#---------------------------------------------------------------------------</span>
    <span class="c1"># constructors</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_blocks</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span>
            <span class="n">raw_blocks</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;TypeBlocks&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        The order of the blocks defines the order of the columns contained.</span>

<span class="sd">        Args:</span>
<span class="sd">            raw_blocks: iterable (generator compatible) of NDArrays.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">blocks</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># ordered blocks</span>
        <span class="n">index</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># columns position to blocks key</span>
        <span class="n">dtypes</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># column position to dtype</span>
        <span class="n">block_count</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># if a single block, no need to loop</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">raw_blocks</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">row_count</span><span class="p">,</span> <span class="n">column_count</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">shape_filter</span><span class="p">(</span><span class="n">raw_blocks</span><span class="p">)</span>
            <span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">immutable_filter</span><span class="p">(</span><span class="n">raw_blocks</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">column_count</span><span class="p">):</span>
                <span class="n">index</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">block_count</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
                <span class="n">dtypes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">raw_blocks</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span> <span class="c1"># an iterable of blocks</span>
            <span class="n">row_count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">column_count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">raw_blocks</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span> <span class="s1">&#39;found non array block: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">block</span>
                <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;cannot include array with more than 2 dimensions&#39;</span><span class="p">)</span>

                <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">shape_filter</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
                <span class="c1"># check number of rows is the same for all blocks</span>
                <span class="k">if</span> <span class="n">row_count</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">r</span> <span class="o">==</span> <span class="n">row_count</span><span class="p">,</span> <span class="s1">&#39;mismatched row count: </span><span class="si">%s</span><span class="s1">: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">row_count</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># assign on first</span>
                    <span class="n">row_count</span> <span class="o">=</span> <span class="n">r</span>

                <span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">immutable_filter</span><span class="p">(</span><span class="n">block</span><span class="p">))</span>

                <span class="c1"># store position to key of block, block columns</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
                    <span class="n">index</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">block_count</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
                    <span class="n">dtypes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">column_count</span> <span class="o">+=</span> <span class="n">c</span>
                <span class="n">block_count</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># blocks cam be empty</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">blocks</span><span class="o">=</span><span class="n">blocks</span><span class="p">,</span>
                <span class="n">dtypes</span><span class="o">=</span><span class="n">dtypes</span><span class="p">,</span>
                <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
                <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">row_count</span><span class="p">,</span> <span class="n">column_count</span><span class="p">),</span>
                <span class="p">)</span>


    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_element_items</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">items</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Given a generator of pairs of iloc coords and values, return a TypeBlock of the desired shape and dtype.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">_dtype_to_na</span><span class="p">(</span><span class="n">dtype</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">iloc</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
            <span class="n">a</span><span class="p">[</span><span class="n">iloc</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="n">a</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_blocks</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>


    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_none</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">blocks</span><span class="o">=</span><span class="nb">list</span><span class="p">(),</span> <span class="n">dtypes</span><span class="o">=</span><span class="nb">list</span><span class="p">(),</span> <span class="n">index</span><span class="o">=</span><span class="nb">list</span><span class="p">(),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

    <span class="c1">#---------------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
            <span class="n">blocks</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
            <span class="n">dtypes</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">],</span>
            <span class="n">index</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="n">tp</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
            <span class="n">shape</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="c1"># could be derived</span>
            <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Args:</span>
<span class="sd">            blocks: A list of one or two-dimensional NumPy arrays</span>
<span class="sd">            dtypes: list of dtypes per external column</span>
<span class="sd">            index: list of tuple coordinates, where list index is external column and the tuple is the block, intra-block column</span>
<span class="sd">            shape: two-element tuple defining row and column count. A (0, 0) shape is permitted for empty TypeBlocks.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span> <span class="o">=</span> <span class="n">blocks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dtypes</span> <span class="o">=</span> <span class="n">dtypes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="n">index</span> <span class="c1"># list where index, as column, gets block, offset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span> <span class="o">=</span> <span class="n">shape</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_row_dtype</span> <span class="o">=</span> <span class="n">_resolve_dtype_iter</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">dtype</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_row_dtype</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># assert len(self._dtypes) == len(self._index) == self._shape[1]</span>

        <span class="c1"># set up callbacks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span> <span class="o">=</span> <span class="n">GetItem</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_extract_iloc</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TypeBlocks&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a new TypeBlocks. Underlying arrays do not need to be copied.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
                <span class="n">blocks</span><span class="o">=</span><span class="p">[</span><span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">],</span>
                <span class="n">dtypes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_dtypes</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="c1"># list</span>
                <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">)</span>

    <span class="c1">#---------------------------------------------------------------------------</span>
    <span class="c1"># new properties</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtypes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return an immutable array that, for each realizable column (not each block), the dtype is given.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># this creates a new array every time it is called; could cache</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dtypes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">a</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">a</span>

    <span class="c1"># consider renaming pointers</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mloc</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;Return an immutable ndarray of NP array memory location integers.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span>
                <span class="p">(</span><span class="n">mloc</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">),</span>
                <span class="n">count</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">a</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">a</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">unified</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span>

    <span class="c1">#---------------------------------------------------------------------------</span>
    <span class="c1"># common NP-style properties</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tp</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="c1"># make this a property so as to be immutable</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">2</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nbytes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">nbytes</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">)</span>

    <span class="c1">#---------------------------------------------------------------------------</span>
    <span class="c1"># value extraction</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_blocks_to_array</span><span class="p">(</span><span class="o">*</span><span class="p">,</span> <span class="n">blocks</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">row_dtype</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Given blocks and a combined shape, return a consolidated single array.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># get empty array and fill parts</span>
        <span class="k">if</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># greturn 1 column TypeBlock as a 1D array with length equal to the number of columns</span>
            <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">row_dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># get ndim 2 shape array</span>
            <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">row_dtype</span><span class="p">)</span>

        <span class="c1"># can we use a np.concatenate, but need to handle 1D arrrays and need to converty type before concatenate</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">blocks</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">block</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">array</span><span class="p">[</span><span class="n">pos</span><span class="p">:</span> <span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span><span class="p">[:]</span> <span class="c1"># gets a row from array</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">array</span><span class="p">[:,</span> <span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span><span class="p">[:]</span> <span class="c1"># a 1d array</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">array</span><span class="p">[:,</span> <span class="n">pos</span><span class="p">:</span> <span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span><span class="p">[:]</span> <span class="c1"># gets a row / row slice from array</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">end</span>

        <span class="n">array</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">array</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;Returns a consolidated NP array of the all blocks.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks_to_array</span><span class="p">(</span>
                <span class="n">blocks</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">,</span>
                <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">,</span>
                <span class="n">row_dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_row_dtype</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">axis_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tp</span><span class="o">.</span><span class="n">Generator</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&#39;&#39;&#39;Generator of arrays produced along an axis.</span>

<span class="sd">        Args:</span>
<span class="sd">            axis: 0 iterates over columns, 1 iterates over rows</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># NOTE: can add a reverse argument here and iterate in reverse; this could be useful if we need to pass rows/cols to lexsort, as in _array_to_duplicated</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># iterate over rows</span>
            <span class="n">unified</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unified</span>
            <span class="c1"># iterate over rows; might be faster to create entire values</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">reverse</span><span class="p">:</span>
                <span class="n">row_idx_iter</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">row_idx_iter</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">row_idx_iter</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">unified</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># cannot use a generator w/ np concat</span>
                    <span class="c1"># use == for type comparisons</span>
                    <span class="n">parts</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="c1"># get a slice to permit concatenation</span>
                            <span class="n">key</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">key</span> <span class="o">=</span> <span class="n">i</span>
                        <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_row_dtype</span><span class="p">:</span>
                            <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_row_dtype</span><span class="p">))</span>
                    <span class="k">yield</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># iterate over columns</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">reverse</span><span class="p">:</span>
                <span class="n">block_column_iter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">block_column_iter</span> <span class="o">=</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">block_idx</span><span class="p">,</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">block_column_iter</span><span class="p">:</span>
                <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">[</span><span class="n">block_idx</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">b</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">b</span><span class="p">[:,</span> <span class="n">column</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">element_items</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tp</span><span class="o">.</span><span class="n">Generator</span><span class="p">[</span>
            <span class="n">tp</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">tp</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">tp</span><span class="o">.</span><span class="n">Any</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Generator of pairs of iloc locations, values accross entire TypeBlock.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1">#np.ndindex(self._shape) # get all target indices</span>
        <span class="n">offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">([</span><span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">else</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">])</span>
        <span class="n">gens</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">single_column_filter</span><span class="p">(</span><span class="n">b</span><span class="p">))</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">iloc</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">):</span>
            <span class="n">block_idx</span><span class="p">,</span> <span class="n">column</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">[</span><span class="n">block_idx</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">iloc</span><span class="p">,</span> <span class="n">b</span><span class="p">[</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">iloc</span><span class="p">,</span> <span class="n">b</span><span class="p">[</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">column</span><span class="p">]</span>

    <span class="c1">#---------------------------------------------------------------------------</span>
    <span class="c1"># methods for evaluating compatibility with other blocks, and reblocking</span>

    <span class="k">def</span> <span class="nf">block_compatible</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">other</span><span class="p">:</span> <span class="s1">&#39;TypeBlocks&#39;</span><span class="p">,</span>
            <span class="n">by_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;Block compatible means that the blocks are the same shape and the same (or compatible) dtype.</span>

<span class="sd">        Args:</span>
<span class="sd">            by_shape: If True, the full shape is compared; if False, only the columns width iis compared.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">zip_longest</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_blocks</span><span class="p">,</span> <span class="n">fillvalue</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">b</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">by_shape</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape_filter</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape_filter</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape_filter</span><span class="p">(</span><span class="n">a</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape_filter</span><span class="p">(</span><span class="n">b</span><span class="p">)[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="c1"># this does not show us if the types can be operated on;</span>
            <span class="c1"># similarly, np.can_cast, np.result_type do not telll us if an operation will succeede</span>
            <span class="c1"># if not a.dtype is b.dtype:</span>
            <span class="c1">#     return False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">reblock_compatible</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s1">&#39;TypeBlocks&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return True if post reblocking these TypeBlocks are compatible. This only compares columns in blocks, not the entire shape.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># we only compare size, not the type</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">b</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">zip_longest</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_reblock_signature</span><span class="p">(),</span>
                <span class="n">other</span><span class="o">.</span><span class="n">_reblock_signature</span><span class="p">())):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_concatenate_blocks</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">group</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">cls</span><span class="o">.</span><span class="n">single_column_filter</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">group</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">consolidate_blocks</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span>
            <span class="n">raw_blocks</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">tp</span><span class="o">.</span><span class="n">Generator</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Generator consumer, generator producer of np.ndarray, consolidating if types are exact matches. Possible improvement to discover when a type can correctly old another type.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">group_dtype</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># store type found along contiguous blocks</span>
        <span class="n">group</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">raw_blocks</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">group_dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># first block of a type</span>
                <span class="n">group_dtype</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">dtype</span>
                <span class="n">group</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">group_dtype</span><span class="p">:</span>
                <span class="c1"># new group found, return stored</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># return reference without copy</span>
                    <span class="k">yield</span> <span class="n">group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># combine groups</span>
                    <span class="c1"># could pre allocating and assing as necessary for large groups</span>
                    <span class="k">yield</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_concatenate_blocks</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
                <span class="n">group_dtype</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">dtype</span>
                <span class="n">group</span> <span class="o">=</span> <span class="p">[</span><span class="n">block</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># new block has same group dtype</span>
                <span class="n">group</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>

        <span class="c1"># get anything leftover</span>
        <span class="k">if</span> <span class="n">group</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_concatenate_blocks</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_reblock</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tp</span><span class="o">.</span><span class="n">Generator</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&#39;&#39;&#39;Generator of new block that consolidate adjacent types that are the same.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">consolidate_blocks</span><span class="p">(</span><span class="n">raw_blocks</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">consolidate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TypeBlocks&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;Return a new TypeBlocks that unifies all adjacent types.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># note: not sure if we have a single block if we should return a new TypeBlocks instance (as done presently), or simply return self; either way, no new np arrays will be created</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_blocks</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">consolidate_blocks</span><span class="p">(</span><span class="n">raw_blocks</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">))</span>


    <span class="k">def</span> <span class="nf">_reblock_signature</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tp</span><span class="o">.</span><span class="n">Generator</span><span class="p">[</span><span class="n">tp</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&#39;&#39;&#39;For anticipating if a reblock will result in a compatible block configuration for operator application, get the reblock signature, providing the dtype and size for each block without actually reblocking.</span>

<span class="sd">        This is a generator to permit lazy pairwise comparison.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">group_dtype</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># store type found along contiguous blocks</span>
        <span class="n">group_cols</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">group_dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># first block of a type</span>
                <span class="n">group_dtype</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">dtype</span>
                <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">group_cols</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">group_cols</span> <span class="o">+=</span> <span class="n">block</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">group_dtype</span><span class="p">:</span>
                <span class="k">yield</span> <span class="p">(</span><span class="n">group_dtype</span><span class="p">,</span> <span class="n">group_cols</span><span class="p">)</span>
                <span class="n">group_dtype</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">dtype</span>
                <span class="n">group_cols</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">group_cols</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">group_cols</span> <span class="o">+=</span> <span class="n">block</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">group_cols</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">yield</span> <span class="p">(</span><span class="n">group_dtype</span><span class="p">,</span> <span class="n">group_cols</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">resize_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
            <span class="n">index_ic</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">IndexCorrespondence</span><span class="p">],</span>
            <span class="n">columns_ic</span> <span class="o">=</span> <span class="n">tp</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">IndexCorrespondence</span><span class="p">],</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="n">tp</span><span class="o">.</span><span class="n">Any</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tp</span><span class="o">.</span><span class="n">Generator</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Given index and column IndexCorrespondence objects, return a generator of resized blocks, extracting from self based on correspondence. Used for Frame.reindex()</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">columns_ic</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">index_ic</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">b</span>

        <span class="k">elif</span> <span class="n">columns_ic</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">index_ic</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">index_ic</span><span class="o">.</span><span class="n">is_subset</span><span class="p">:</span>
                    <span class="c1"># works for both 1d and 2s arrays</span>
                    <span class="k">yield</span> <span class="n">b</span><span class="p">[</span><span class="n">index_ic</span><span class="o">.</span><span class="n">iloc_src</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">shape</span> <span class="o">=</span> <span class="n">index_ic</span><span class="o">.</span><span class="n">size</span> <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">(</span><span class="n">index_ic</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">values</span> <span class="o">=</span> <span class="n">_full_for_fill</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">index_ic</span><span class="o">.</span><span class="n">has_common</span><span class="p">:</span>
                        <span class="n">values</span><span class="p">[</span><span class="n">index_ic</span><span class="o">.</span><span class="n">iloc_dst</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">index_ic</span><span class="o">.</span><span class="n">iloc_src</span><span class="p">]</span>
                    <span class="n">values</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">yield</span> <span class="n">values</span>

        <span class="k">elif</span> <span class="n">columns_ic</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">index_ic</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">columns_ic</span><span class="o">.</span><span class="n">has_common</span><span class="p">:</span>
                <span class="c1"># just return an empty frame; what type it shold be is not clear</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">columns_ic</span><span class="o">.</span><span class="n">size</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">_full_for_fill</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_row_dtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
                <span class="n">values</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">yield</span> <span class="n">values</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unified</span> <span class="ow">and</span> <span class="n">columns_ic</span><span class="o">.</span><span class="n">is_subset</span><span class="p">:</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">yield</span> <span class="n">b</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">yield</span> <span class="n">b</span><span class="p">[:,</span> <span class="n">columns_ic</span><span class="o">.</span><span class="n">iloc_src</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dst_to_src</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">columns_ic</span><span class="o">.</span><span class="n">iloc_dst</span><span class="p">,</span> <span class="n">columns_ic</span><span class="o">.</span><span class="n">iloc_src</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">columns_ic</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">dst_to_src</span><span class="p">:</span>
                            <span class="n">block_idx</span><span class="p">,</span> <span class="n">block_col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">dst_to_src</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span>
                            <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">[</span><span class="n">block_idx</span><span class="p">]</span>
                            <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="k">yield</span> <span class="n">b</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">yield</span> <span class="n">b</span><span class="p">[:,</span> <span class="n">block_col</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># just get an empty position</span>
                            <span class="c1"># dtype should be the same as the column replacing?</span>
                            <span class="n">values</span> <span class="o">=</span> <span class="n">_full_for_fill</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_row_dtype</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                    <span class="n">fill_value</span><span class="p">)</span>
                            <span class="n">values</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="k">yield</span> <span class="n">values</span>

        <span class="k">else</span><span class="p">:</span> <span class="c1"># both defined</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">columns_ic</span><span class="o">.</span><span class="n">has_common</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">index_ic</span><span class="o">.</span><span class="n">has_common</span><span class="p">:</span>
                <span class="c1"># just return an empty frame; what type it shold be is not clear</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="n">index_ic</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">columns_ic</span><span class="o">.</span><span class="n">size</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">_full_for_fill</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_row_dtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
                <span class="n">values</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">yield</span> <span class="n">values</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unified</span> <span class="ow">and</span> <span class="n">index_ic</span><span class="o">.</span><span class="n">is_subset</span> <span class="ow">and</span> <span class="n">columns_ic</span><span class="o">.</span><span class="n">is_subset</span><span class="p">:</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">yield</span> <span class="n">b</span><span class="p">[</span><span class="n">index_ic</span><span class="o">.</span><span class="n">iloc_src</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">yield</span> <span class="n">b</span><span class="p">[</span><span class="n">index_ic</span><span class="o">.</span><span class="n">iloc_src_fancy</span><span class="p">(),</span> <span class="n">columns_ic</span><span class="o">.</span><span class="n">iloc_src</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">columns_dst_to_src</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">columns_ic</span><span class="o">.</span><span class="n">iloc_dst</span><span class="p">,</span> <span class="n">columns_ic</span><span class="o">.</span><span class="n">iloc_src</span><span class="p">))</span>

                    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">columns_ic</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">columns_dst_to_src</span><span class="p">:</span>
                            <span class="n">block_idx</span><span class="p">,</span> <span class="n">block_col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">columns_dst_to_src</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span>
                            <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">[</span><span class="n">block_idx</span><span class="p">]</span>

                            <span class="k">if</span> <span class="n">index_ic</span><span class="o">.</span><span class="n">is_subset</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                    <span class="k">yield</span> <span class="n">b</span><span class="p">[</span><span class="n">index_ic</span><span class="o">.</span><span class="n">iloc_src</span><span class="p">]</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="k">yield</span> <span class="n">b</span><span class="p">[</span><span class="n">index_ic</span><span class="o">.</span><span class="n">iloc_src</span><span class="p">,</span> <span class="n">block_col</span><span class="p">]</span>
                            <span class="k">else</span><span class="p">:</span> <span class="c1"># need an empty to fill</span>
                                <span class="n">values</span> <span class="o">=</span> <span class="n">_full_for_fill</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_row_dtype</span><span class="p">,</span>
                                        <span class="n">index_ic</span><span class="o">.</span><span class="n">size</span><span class="p">,</span>
                                        <span class="n">fill_value</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                    <span class="n">values</span><span class="p">[</span><span class="n">index_ic</span><span class="o">.</span><span class="n">iloc_dst</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">index_ic</span><span class="o">.</span><span class="n">iloc_src</span><span class="p">]</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">values</span><span class="p">[</span><span class="n">index_ic</span><span class="o">.</span><span class="n">iloc_dst</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">index_ic</span><span class="o">.</span><span class="n">iloc_src</span><span class="p">,</span> <span class="n">block_col</span><span class="p">]</span>
                                <span class="n">values</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
                                <span class="k">yield</span> <span class="n">values</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">values</span> <span class="o">=</span> <span class="n">_full_for_fill</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_row_dtype</span><span class="p">,</span>
                                        <span class="n">index_ic</span><span class="o">.</span><span class="n">size</span><span class="p">,</span>
                                        <span class="n">fill_value</span><span class="p">)</span>
                            <span class="n">values</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="k">yield</span> <span class="n">values</span>


    <span class="k">def</span> <span class="nf">group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">axis</span><span class="p">,</span>
            <span class="n">key</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tp</span><span class="o">.</span><span class="n">Generator</span><span class="p">[</span><span class="n">tp</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">tp</span><span class="o">.</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Args:</span>
<span class="sd">            key: iloc selector on opposite axis</span>

<span class="sd">        Returns:</span>
<span class="sd">            Generator of group, selection pairs, where selection is an np.ndaarray</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># in worse case this will make a copy of the values extracted; this is probably still cheaper than iterating manually through rows/columns</span>
        <span class="n">unique_axis</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># axis 0 means we return row groups; key is a column key</span>
            <span class="n">group_source</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_array</span><span class="p">(</span><span class="n">column_key</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">group_source</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">unique_axis</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># axis 1 means we return column groups; key is a row key</span>
            <span class="n">group_source</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_array</span><span class="p">(</span><span class="n">row_key</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">group_source</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">unique_axis</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">groups</span><span class="p">,</span> <span class="n">locations</span> <span class="o">=</span> <span class="n">_array_to_groups_and_locations</span><span class="p">(</span>
                <span class="n">group_source</span><span class="p">,</span>
                <span class="n">unique_axis</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">groups</span><span class="p">):</span>
            <span class="n">selection</span> <span class="o">=</span> <span class="n">locations</span> <span class="o">==</span> <span class="n">idx</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># return row extractions</span>
                <span class="k">yield</span> <span class="n">g</span><span class="p">,</span> <span class="n">selection</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract</span><span class="p">(</span><span class="n">row_key</span><span class="o">=</span><span class="n">selection</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># return columns extractions</span>
                <span class="k">yield</span> <span class="n">g</span><span class="p">,</span> <span class="n">selection</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract</span><span class="p">(</span><span class="n">column_key</span><span class="o">=</span><span class="n">selection</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">block_apply_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;Apply a function that reduces blocks to a single axis.</span>

<span class="sd">        Args:</span>
<span class="sd">            dtype: if we know the return type of func, we can provide it here to avoid having to use the row dtype.</span>

<span class="sd">        Returns:</span>
<span class="sd">            As this is a reduction of axis where the caller (a Frame) is likely to return a Series, this function is not a generator of blocks, but instead just returns a consolidated 1d array.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">assert</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unified</span><span class="p">:</span>
            <span class="c1"># TODO: not sure if we need dim filter here</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># need to have good row dtype here, so that ints goes to floats</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># reduce all rows to 1d with column width</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># reduce all columns to 2d blocks with 1 column</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">))</span>

            <span class="c1"># this will be uninitialzied and thuse, if a value is not assigned, will have garbage</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_row_dtype</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">end</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="n">out</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">end</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">temp</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span> <span class="o">!=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">pos</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;unexpected.&#39;</span><span class="p">)</span>
                        <span class="n">func</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">[</span><span class="n">pos</span><span class="p">:</span> <span class="n">end</span><span class="p">])</span>
                    <span class="n">pos</span> <span class="o">=</span> <span class="n">end</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># cannot process yet</span>
                        <span class="c1"># if this is a numeric single columns we just copy it and process it later; but if this is a logical application (and, or) then out is already boolean</span>
                        <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span> <span class="ow">and</span> <span class="n">b</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="nb">bool</span><span class="p">:</span>
                            <span class="c1"># making 2D with axis 0 func will result in element-wise operation</span>
                            <span class="n">out</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">single_column_filter</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span> <span class="c1"># otherwise, keep as is</span>
                            <span class="n">out</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">func</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># nothing more to do</span>
            <span class="n">out</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="n">out</span>
        <span class="c1"># must call function one more time on remaining components</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="c1">#---------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Length, as with NumPy and Pandas, is the number of rows.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


    <span class="k">def</span> <span class="nf">display</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">:</span> <span class="n">DisplayConfig</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Display</span><span class="p">:</span>
        <span class="n">config</span> <span class="o">=</span> <span class="n">config</span> <span class="ow">or</span> <span class="n">DisplayActive</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>

        <span class="n">h</span> <span class="o">=</span> <span class="s1">&#39;&lt;&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;&gt;&#39;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">block</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">):</span>
            <span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">single_column_filter</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
            <span class="n">header</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span> <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">h</span>
            <span class="n">display</span> <span class="o">=</span> <span class="n">Display</span><span class="o">.</span><span class="n">from_values</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="n">config</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">d</span><span class="p">:</span> <span class="c1"># assign first</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">display</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">d</span><span class="o">.</span><span class="n">append_display</span><span class="p">(</span><span class="n">display</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span> <span class="n">display</span><span class="p">())</span>


    <span class="c1">#---------------------------------------------------------------------------</span>
    <span class="c1"># extraction utilities</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_cols_to_slice</span><span class="p">(</span><span class="n">indices</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">slice</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;Translate an iterable of contiguous integers into a slice</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">start_idx</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># can always represetn a singel column a single slice</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start_idx</span><span class="p">,</span> <span class="n">start_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">stop_idx</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">stop_idx</span> <span class="o">&gt;</span> <span class="n">start_idx</span><span class="p">:</span>            <span class="c1"># ascending indices</span>
            <span class="k">return</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start_idx</span><span class="p">,</span> <span class="n">stop_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">stop_idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start_idx</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># stop is less than start, need to reduce by 1 to cover range</span>
        <span class="k">return</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start_idx</span><span class="p">,</span> <span class="n">stop_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>


    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_indices_to_contiguous_pairs</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tp</span><span class="o">.</span><span class="n">Generator</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;Indices are pairs of (block_idx, value); convert these to pairs of (block_idx, slice) when we identify contiguous indices.</span>

<span class="sd">        Args:</span>
<span class="sd">            indices: can be a generator</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># store pairs of block idx, ascending col list</span>
        <span class="n">last</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">block_idx</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">last</span><span class="p">:</span>
                <span class="n">last</span> <span class="o">=</span> <span class="p">(</span><span class="n">block_idx</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
                <span class="n">bundle</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span><span class="p">]</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">last</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">block_idx</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">col</span> <span class="o">-</span> <span class="n">last</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># if contiguous, update last, add to bundle</span>
                <span class="n">last</span> <span class="o">=</span> <span class="p">(</span><span class="n">block_idx</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
                <span class="n">bundle</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="c1"># either new block, or not contiguous on same block</span>
            <span class="c1"># store what we have so far</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">bundle</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="c1"># yield a pair of block_idx, contiguous slice</span>
            <span class="k">yield</span> <span class="p">(</span><span class="n">last</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_cols_to_slice</span><span class="p">(</span><span class="n">bundle</span><span class="p">))</span>
            <span class="c1"># but this one on bundle</span>
            <span class="n">bundle</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span><span class="p">]</span>
            <span class="n">last</span> <span class="o">=</span> <span class="p">(</span><span class="n">block_idx</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
        <span class="c1"># last might be None if we</span>
        <span class="k">if</span> <span class="n">last</span> <span class="ow">and</span> <span class="n">bundle</span><span class="p">:</span>
            <span class="k">yield</span> <span class="p">(</span><span class="n">last</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_cols_to_slice</span><span class="p">(</span><span class="n">bundle</span><span class="p">))</span>


    <span class="k">def</span> <span class="nf">_key_to_block_slices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tp</span><span class="o">.</span><span class="n">Generator</span><span class="p">[</span>
                <span class="n">tp</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">tp</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">slice</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        For a column key (an integer, slice, or iterable), generate pairs of (block_idx, slice or integer) to cover all extractions. First, get the relevant index values (pairs of block id, column id), then convert those to contiguous slices.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A generator iterable of pairs, where values are block index, slice or column index</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1"># do type checking on slice v others, as with others we need to sort once iterable of keys</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">)):</span>
            <span class="c1"># the index has the pair block, column integer</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="c1"># slice the index</span>
                <span class="c1"># already sorted</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">key</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="kc">True</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">_KEY_ITERABLE_TYPES</span><span class="p">):</span>
                <span class="c1"># an iterable of keys, may not have contiguous regions; provide in the order given; set as a generator; self._index is a list, not an np.array, so cannot slice self._index; requires iteration in passed generator anyways so probably this is as fast as it can be.</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">key</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># get all</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;got key&#39;</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indices_to_contiguous_pairs</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_mask_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">row_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">column_key</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tp</span><span class="o">.</span><span class="n">Generator</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&#39;&#39;&#39;Return Boolean blocks of the same size and shape, where key selection sets values to True.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1"># this selects the columns; but need to return all bloics</span>
        <span class="n">block_slices</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_key_to_block_slices</span><span class="p">(</span><span class="n">column_key</span><span class="p">))</span>
        <span class="n">target_block_idx</span> <span class="o">=</span> <span class="n">target_slice</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">block_idx</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">target_block_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># can be zero</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">target_block_idx</span><span class="p">,</span> <span class="n">target_slice</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">block_slices</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                        <span class="k">break</span>

                <span class="k">if</span> <span class="n">block_idx</span> <span class="o">!=</span> <span class="n">target_block_idx</span><span class="p">:</span>
                    <span class="k">break</span> <span class="c1"># need to advance blocks</span>

                <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># given 1D array, our row key is all we need</span>
                    <span class="n">mask</span><span class="p">[</span><span class="n">row_key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">row_key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">mask</span><span class="p">[:,</span> <span class="n">target_slice</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">mask</span><span class="p">[</span><span class="n">row_key</span><span class="p">,</span> <span class="n">target_slice</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="n">target_block_idx</span> <span class="o">=</span> <span class="n">target_slice</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">yield</span> <span class="n">mask</span>


    <span class="k">def</span> <span class="nf">_assign_blocks_from_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">row_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">column_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tp</span><span class="o">.</span><span class="n">Generator</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&#39;&#39;&#39;Assign value into all blocks, returning blocks of the same size and shape.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">value_dtype</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">value_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span>

        <span class="c1"># this selects the columns; but need to return all blocks</span>
        <span class="n">block_slices</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_key_to_block_slices</span><span class="p">(</span><span class="n">column_key</span><span class="p">))</span>
        <span class="n">target_block_idx</span> <span class="o">=</span> <span class="n">target_slice</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">block_idx</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">):</span>

            <span class="n">assigned</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">target_block_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># can be zero</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">target_block_idx</span><span class="p">,</span> <span class="n">target_slice</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">block_slices</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                        <span class="k">break</span>

                <span class="k">if</span> <span class="n">block_idx</span> <span class="o">!=</span> <span class="n">target_block_idx</span><span class="p">:</span>
                    <span class="k">break</span> <span class="c1"># need to advance blocks, keep targets</span>

                <span class="c1"># from here, we have a target we need to apply</span>
                <span class="k">if</span> <span class="n">assigned</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">assigned_dtype</span> <span class="o">=</span> <span class="n">_resolve_dtype</span><span class="p">(</span><span class="n">value_dtype</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">assigned_dtype</span><span class="p">:</span>
                        <span class="n">assigned</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">assigned</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">assigned_dtype</span><span class="p">)</span>

                <span class="c1"># match sliceable, when target_slice is a slice (can be an integer)</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">target_slice</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span> <span class="ow">and</span>
                        <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
                        <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">width</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">value_piece</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># do not want to slice</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">width</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">target_slice</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">assigned</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
                        <span class="n">value_piece</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">)]</span>
                    <span class="c1"># reassign remainder for next iteration</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># not sliceable</span>
                    <span class="n">value_piece</span> <span class="o">=</span> <span class="n">value</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
                <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># given 1D array, our row key is all we need</span>
                    <span class="n">assigned</span><span class="p">[</span><span class="n">row_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value_piece</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">row_key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">assigned</span><span class="p">[:,</span> <span class="n">target_slice</span><span class="p">]</span> <span class="o">=</span> <span class="n">value_piece</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">assigned</span><span class="p">[</span><span class="n">row_key</span><span class="p">,</span> <span class="n">target_slice</span><span class="p">]</span> <span class="o">=</span> <span class="n">value_piece</span>

                <span class="n">target_block_idx</span> <span class="o">=</span> <span class="n">target_slice</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="n">assigned</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">b</span> <span class="c1"># no change</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># disable writing so clients can keep the array</span>
                <span class="n">assigned</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">yield</span> <span class="n">assigned</span>


    <span class="k">def</span> <span class="nf">_assign_blocks_from_boolean_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">targets</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
            <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tp</span><span class="o">.</span><span class="n">Generator</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&#39;&#39;&#39;Assign value into all blocks based on a Bolean arrays of shape equal to each block in these blocks, returning blocks of the same size and shape. Value is set where the Boolean is True.</span>

<span class="sd">        Args:</span>
<span class="sd">            value: Must be a single value, rather than an array</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;cannot assign an array with Boolean targets&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">value_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span>

        <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">zip_longest</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">,</span> <span class="n">targets</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">block</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">target</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;blocks or targets do not align&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">target</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">block</span>

            <span class="n">assigned_dtype</span> <span class="o">=</span> <span class="n">_resolve_dtype</span><span class="p">(</span><span class="n">value_dtype</span><span class="p">,</span> <span class="n">block</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">assigned_dtype</span><span class="p">:</span>
                <span class="n">assigned</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">assigned</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">assigned_dtype</span><span class="p">)</span>

            <span class="k">assert</span> <span class="n">assigned</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">target</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">assigned</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">yield</span> <span class="n">assigned</span>


    <span class="k">def</span> <span class="nf">_slice_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">row_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">column_key</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tp</span><span class="o">.</span><span class="n">Generator</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Generator of sliced blocks, given row and column key selectors.</span>
<span class="sd">        The result is suitable for pass to TypeBlocks constructor.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">single_row</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">row_key</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">single_row</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">row_key</span><span class="p">,</span> <span class="n">_KEY_ITERABLE_TYPES</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">row_key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># an iterable of index integers is expected here</span>
            <span class="n">single_row</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">row_key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="c1"># need to determine if there is only one index returned by range (after getting indices from the slice); do this without creating a list/tuple, or walking through the entire range; get constant time look-up of range length after uses slice.indicies</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">row_key</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">single_row</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">row_key</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">row_key</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="c1"># TODO: need fastest way to find if there is more than one boolean</span>
            <span class="k">if</span> <span class="n">row_key</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">single_row</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># convert column_key into a series of block slices; we have to do this as we stride blocks; do not have to convert row_key as can use directly per block slice</span>
        <span class="k">for</span> <span class="n">block_idx</span><span class="p">,</span> <span class="n">slc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key_to_block_slices</span><span class="p">(</span><span class="n">column_key</span><span class="p">):</span>
            <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">[</span><span class="n">block_idx</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># given 1D array, our row key is all we need</span>
                <span class="k">if</span> <span class="n">row_key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">block_sliced</span> <span class="o">=</span> <span class="n">b</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">block_sliced</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">row_key</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># given 2D, use row key and column slice</span>
                <span class="k">if</span> <span class="n">row_key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">block_sliced</span> <span class="o">=</span> <span class="n">b</span><span class="p">[:,</span> <span class="n">slc</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">block_sliced</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">row_key</span><span class="p">,</span> <span class="n">slc</span><span class="p">]</span>

            <span class="c1"># optionally, apply additional selection, reshaping, or adjustments to what we got out of the block</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">block_sliced</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="c1"># if we have a single row and the thing we sliced is 1d, we need to rotate it</span>
                <span class="k">if</span> <span class="n">single_row</span> <span class="ow">and</span> <span class="n">block_sliced</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">block_sliced</span> <span class="o">=</span> <span class="n">block_sliced</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">block_sliced</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="c1"># if we have a single column as 2d, unpack it; however, we have to make sure this is not a single row in a 2d</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">block_sliced</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span>
                        <span class="ow">and</span> <span class="n">block_sliced</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
                        <span class="ow">and</span> <span class="ow">not</span> <span class="n">single_row</span><span class="p">):</span>
                    <span class="n">block_sliced</span> <span class="o">=</span> <span class="n">block_sliced</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># a single element, wrap back up in array</span>
                <span class="n">block_sliced</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">block_sliced</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">b</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

            <span class="k">yield</span> <span class="n">block_sliced</span>


    <span class="k">def</span> <span class="nf">_extract_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">row_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">column_key</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;Alternative extractor that returns just an np array, concatenating blocks as necessary. Used for internal clients that want to process row/column with an array</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># identifying column_key as integer, then we only access one block, and can return directly without iterating over blocks</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column_key</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">block_idx</span><span class="p">,</span> <span class="n">column</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">column_key</span><span class="p">]</span>
            <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">[</span><span class="n">block_idx</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">row_key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">b</span>
                <span class="k">return</span> <span class="n">b</span><span class="p">[</span><span class="n">row_key</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">row_key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">b</span><span class="p">[:,</span> <span class="n">column</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">b</span><span class="p">[</span><span class="n">row_key</span><span class="p">,</span> <span class="n">column</span><span class="p">]</span>

        <span class="c1"># pass a generator to from_block; will return a TypeBlocks or a single element</span>
        <span class="c1"># TODO: figure out shape from keys so as to not accumulate?</span>
        <span class="n">blocks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_slice_blocks</span><span class="p">(</span> <span class="c1"># a generator</span>
                <span class="n">row_key</span><span class="o">=</span><span class="n">row_key</span><span class="p">,</span>
                <span class="n">column_key</span><span class="o">=</span><span class="n">column_key</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># it is a single column</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">rows</span><span class="p">:</span> <span class="c1"># assume all the same after first</span>
                    <span class="c1"># if 1d, then the length should be the number of rows</span>
                    <span class="n">rows</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">columns</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">rows</span><span class="p">:</span> <span class="c1"># assume all the same after first</span>
                    <span class="n">rows</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">columns</span> <span class="o">+=</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks_to_array</span><span class="p">(</span>
                <span class="n">blocks</span><span class="o">=</span><span class="n">blocks</span><span class="p">,</span>
                <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">columns</span><span class="p">),</span>
                <span class="n">row_dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_row_dtype</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_extract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">row_key</span><span class="p">:</span> <span class="n">GetItemKeyType</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">column_key</span><span class="p">:</span> <span class="n">GetItemKeyType</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TypeBlocks&#39;</span><span class="p">:</span> <span class="c1"># but sometimes an element</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a TypeBlocks after performing row and column selection using iloc selection.</span>

<span class="sd">        Row and column keys can be:</span>
<span class="sd">            integer: single row/column selection</span>
<span class="sd">            slices: one or more contiguous selections</span>
<span class="sd">            iterable of integers: one or more non-contiguous and/or repeated selections</span>

<span class="sd">        Note: Boolean-based selection is not (yet?) implemented here, but instead will be implemented at the `loc` level. This might imply that Boolean selection is only available with `loc`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            TypeBlocks, or a single element if both are coordinats</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># identifying column_key as integer, then we only access one block, and can return directly without iterating over blocks</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column_key</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">block_idx</span><span class="p">,</span> <span class="n">column</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">column_key</span><span class="p">]</span>
            <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">[</span><span class="n">block_idx</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">row_key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># return a column</span>
                    <span class="k">return</span> <span class="n">TypeBlocks</span><span class="o">.</span><span class="n">from_blocks</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">row_key</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">b</span><span class="p">[</span><span class="n">row_key</span><span class="p">]</span> <span class="c1"># return single item</span>
                <span class="k">return</span> <span class="n">TypeBlocks</span><span class="o">.</span><span class="n">from_blocks</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">row_key</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">row_key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># return a column</span>
                <span class="k">return</span> <span class="n">TypeBlocks</span><span class="o">.</span><span class="n">from_blocks</span><span class="p">(</span><span class="n">b</span><span class="p">[:,</span> <span class="n">column</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">row_key</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">b</span><span class="p">[</span><span class="n">row_key</span><span class="p">,</span> <span class="n">column</span><span class="p">]</span> <span class="c1"># return single item</span>
            <span class="k">return</span> <span class="n">TypeBlocks</span><span class="o">.</span><span class="n">from_blocks</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">row_key</span><span class="p">,</span> <span class="n">column</span><span class="p">])</span>

        <span class="c1"># pass a generator to from_block; will return a TypeBlocks or a single element</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_blocks</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_slice_blocks</span><span class="p">(</span>
                <span class="n">row_key</span><span class="o">=</span><span class="n">row_key</span><span class="p">,</span>
                <span class="n">column_key</span><span class="o">=</span><span class="n">column_key</span><span class="p">))</span>


    <span class="k">def</span> <span class="nf">_extract_iloc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">key</span><span class="p">:</span> <span class="n">GetItemKeyTypeCompound</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TypeBlocks&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unified</span><span class="p">:</span>
            <span class="c1"># perform slicing directly on block if possible</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_blocks</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">key</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract</span><span class="p">(</span><span class="o">*</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract</span><span class="p">(</span><span class="n">row_key</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">extract_iloc_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">key</span><span class="p">:</span> <span class="n">GetItemKeyTypeCompound</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TypeBlocks&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">TypeBlocks</span><span class="o">.</span><span class="n">from_blocks</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask_blocks</span><span class="p">(</span><span class="o">*</span><span class="n">key</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">TypeBlocks</span><span class="o">.</span><span class="n">from_blocks</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask_blocks</span><span class="p">(</span><span class="n">row_key</span><span class="o">=</span><span class="n">key</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">extract_iloc_assign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">key</span><span class="p">:</span> <span class="n">GetItemKeyTypeCompound</span><span class="p">,</span>
            <span class="n">value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TypeBlocks&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">TypeBlocks</span><span class="o">.</span><span class="n">from_blocks</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_assign_blocks_from_keys</span><span class="p">(</span><span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">TypeBlocks</span><span class="o">.</span><span class="n">from_blocks</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_assign_blocks_from_keys</span><span class="p">(</span><span class="n">row_key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">))</span>


    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TypeBlocks&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns a column, or a column slice.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># NOTE: if key is a tuple it means that multiple indices are being provided; this should probably raise an error</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;__getitem__ does not support multiple indexers&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract</span><span class="p">(</span><span class="n">row_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">column_key</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>

    <span class="c1">#---------------------------------------------------------------------------</span>
    <span class="c1"># operators</span>

    <span class="k">def</span> <span class="nf">_ufunc_unary_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Callable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TypeBlocks&#39;</span><span class="p">:</span>
        <span class="c1"># for now, do no reblocking; though, in many cases, operating on a unified block will be faster</span>
        <span class="k">def</span> <span class="nf">operation</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">operator</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                <span class="n">result</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">yield</span> <span class="n">result</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_blocks</span><span class="p">(</span><span class="n">operation</span><span class="p">())</span>

    <span class="c1">#---------------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">_block_shape_slices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tp</span><span class="o">.</span><span class="n">Generator</span><span class="p">[</span><span class="nb">slice</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&#39;&#39;&#39;Generator of slices necessary to slice a 1d array of length equal to the number of columns into a lenght suitable for each block.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">yield</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">end</span>

    <span class="k">def</span> <span class="nf">_ufunc_binary_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">operator</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Callable</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TypeBlocks&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TypeBlocks</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_compatible</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
                <span class="c1"># this means that the blocks are the same size; we do not check types</span>
                <span class="n">self_opperands</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span>
                <span class="n">other_opperands</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_blocks</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_shape</span><span class="p">:</span>
                <span class="c1"># if the result of reblock does not result in compatible shapes, we have to use .values as opperands; the dtypes can be different so we only have to check that they columns sizes, the second element of the signature, all match.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">reblock_compatible</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
                    <span class="n">self_opperands</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,)</span>
                    <span class="n">other_opperands</span> <span class="o">=</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">values</span><span class="p">,)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">self_opperands</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reblock</span><span class="p">()</span>
                    <span class="n">other_opperands</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_reblock</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># raise same error as NP</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;cannot apply binary operators to arbitrary TypeBlocks&#39;</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">operation</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">zip_longest</span><span class="p">(</span>
                        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">single_column_filter</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">self_opperands</span><span class="p">),</span>
                        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">single_column_filter</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">other_opperands</span><span class="p">)</span>
                        <span class="p">):</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">operator</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># own the data</span>
                    <span class="k">yield</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># process other as an array</span>
            <span class="n">self_opperands</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="c1"># this maybe expensive for a single scalar</span>
                <span class="n">other</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="c1"># this will work with a single scalar too</span>

            <span class="c1"># handle dimensions</span>
            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                <span class="c1"># a scalar: reference same value for each block position</span>
                <span class="n">other_opperands</span> <span class="o">=</span> <span class="p">(</span><span class="n">other</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">)))</span>
            <span class="k">elif</span> <span class="n">other</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="c1"># if given a 1d array</span>
                <span class="c1"># one dimensional array of same size: chop to block width</span>
                <span class="n">other_opperands</span> <span class="o">=</span> <span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_block_shape_slices</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;cannot apply binary operators to arbitrary np arrays.&#39;</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">operation</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">zip_longest</span><span class="p">(</span><span class="n">self_opperands</span><span class="p">,</span> <span class="n">other_opperands</span><span class="p">):</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">operator</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># own the data</span>
                    <span class="k">yield</span> <span class="n">result</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_blocks</span><span class="p">(</span><span class="n">operation</span><span class="p">())</span>



    <span class="k">def</span> <span class="nf">_ufunc_axis_skipna</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="p">,</span> <span class="n">ufunc</span><span class="p">,</span> <span class="n">ufunc_skipna</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
        <span class="c1"># not sure if these make sense on TypeBlocks, as they reduce dimensionality</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="c1">#---------------------------------------------------------------------------</span>
    <span class="c1"># transformations resulting in the same dimensionality</span>

    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TypeBlocks&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;Return a new TypeBlocks that transposes and concatenates all blocks.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">blocks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">single_column_filter</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_row_dtype</span><span class="p">:</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_row_dtype</span><span class="p">)</span>
            <span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span>
        <span class="n">a</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># keep this array</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_blocks</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">isna</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TypeBlocks&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;Return a Boolean TypeBlocks where True is NaN or None.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">def</span> <span class="nf">blocks</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">:</span>
                <span class="n">bool_block</span> <span class="o">=</span> <span class="n">_isna</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                <span class="n">bool_block</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">yield</span> <span class="n">bool_block</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_blocks</span><span class="p">(</span><span class="n">blocks</span><span class="p">())</span>


    <span class="k">def</span> <span class="nf">notna</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TypeBlocks&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;Return a Boolean TypeBlocks where True is not NaN or None.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">def</span> <span class="nf">blocks</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">:</span>
                <span class="n">bool_block</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">_isna</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
                <span class="n">bool_block</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">yield</span> <span class="n">bool_block</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_blocks</span><span class="p">(</span><span class="n">blocks</span><span class="p">())</span>


    <span class="k">def</span> <span class="nf">dropna_to_keep_locations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">condition</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Callable</span><span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TypeBlocks&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return the row and column slices to extract the new TypeBlock. This is to be used by Frame, where the slices will be needed on the indices as well.</span>

<span class="sd">        Args:</span>
<span class="sd">            axis: Dimension to drop, where 0 will drop rows and 1 will drop columns based on the condition function applied to a Boolean array.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># get a unified boolean array; as iisna will always return a Boolean, we can simply take the firtst block out of consolidation</span>
        <span class="n">unified</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">consolidate_blocks</span><span class="p">(</span><span class="n">_isna</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">))</span>

        <span class="c1"># flip axis to condition funcion</span>
        <span class="n">condition_axis</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">axis</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="n">to_drop</span> <span class="o">=</span> <span class="n">condition</span><span class="p">(</span><span class="n">unified</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">condition_axis</span><span class="p">)</span>
        <span class="n">to_keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">to_drop</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">row_key</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">column_key</span> <span class="o">=</span> <span class="n">to_keep</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">row_key</span> <span class="o">=</span> <span class="n">to_keep</span>
            <span class="n">column_key</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">row_key</span><span class="p">,</span> <span class="n">column_key</span>


    <span class="k">def</span> <span class="nf">fillna</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TypeBlocks&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a new TypeBlocks instance that fills missing values with the passed value.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_blocks</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_assign_blocks_from_boolean_blocks</span><span class="p">(</span>
                        <span class="n">targets</span><span class="o">=</span><span class="p">(</span><span class="n">_isna</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">),</span>
                        <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
                <span class="p">)</span>


    <span class="c1">#---------------------------------------------------------------------------</span>
    <span class="c1"># mutate</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Add a block; an array copy will not be made unless the passed in block is not immutable&#39;&#39;&#39;</span>
        <span class="c1"># shape can be 0, 0 if empty</span>
        <span class="n">row_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># update shape</span>
        <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">row_count</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="o">==</span> <span class="n">row_count</span><span class="p">,</span> <span class="s1">&#39;mismatched row count&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">row_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
            <span class="n">block_columns</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">row_count</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">block</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">row_count</span><span class="p">,</span> <span class="s1">&#39;mismatched row count&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">row_count</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">block_columns</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>


        <span class="c1"># extend shape, or define it if not yet set</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">row_count</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">block_columns</span><span class="p">)</span>

        <span class="c1"># add block, dtypes, index</span>
        <span class="n">block_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">)</span> <span class="c1"># next block</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">block_columns</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">block_idx</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dtypes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># make immutable copy if necessary before appending</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">immutable_filter</span><span class="p">(</span><span class="n">block</span><span class="p">))</span>

        <span class="c1"># if already aligned, nothing to do</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_row_dtype</span><span class="p">:</span> <span class="c1"># if never set as shape is empty</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_row_dtype</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">elif</span> <span class="n">block</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_row_dtype</span><span class="p">:</span>
            <span class="c1"># we do not use _resolve_dtype here as we want to preserve types, not safely cooerce them (i.e., int to float)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_row_dtype</span> <span class="o">=</span> <span class="nb">object</span>

    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s1">&#39;TypeBlocks&#39;</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Extend this TypeBlock with the contents of another.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TypeBlocks</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">blocks</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_blocks</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># accept iterables of np.arrays</span>
            <span class="n">blocks</span> <span class="o">=</span> <span class="n">other</span>
        <span class="c1"># row count must be the same</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">blocks</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">block</span><span class="p">)</span></div>


<span class="c1">#-------------------------------------------------------------------------------</span>
<span class="k">class</span> <span class="nc">LocMap</span><span class="p">:</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">map_slice_args</span><span class="p">(</span><span class="n">label_to_pos</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">slice</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Given a slice and a label to position mapping, yield each argument necessary to create a new slice.</span>

<span class="sd">        Args:</span>
<span class="sd">            label_to_pos: mapping, no order dependency</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># TODO: just iter over (key.start) etc.</span>
        <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;start&#39;</span><span class="p">,</span> <span class="s1">&#39;stop&#39;</span><span class="p">,</span> <span class="s1">&#39;step&#39;</span><span class="p">):</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">attr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">yield</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">field</span> <span class="o">==</span> <span class="s1">&#39;stop&#39;</span><span class="p">:</span>
                    <span class="c1"># loc selections are inclusive, so iloc gets one more</span>
                    <span class="k">yield</span> <span class="n">label_to_pos</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">label_to_pos</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">loc_to_iloc</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span>
            <span class="n">label_to_pos</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Dict</span><span class="p">,</span>
            <span class="n">positions</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
            <span class="n">key</span><span class="p">:</span> <span class="n">GetItemKeyType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">GetItemKeyType</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns:</span>
<span class="sd">            A integer mapped slice, or GetItemKey type that is based on integers, compatible with TypeBlocks</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">slice</span><span class="p">(</span><span class="o">*</span><span class="bp">cls</span><span class="o">.</span><span class="n">map_slice_args</span><span class="p">(</span><span class="n">label_to_pos</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">_KEY_ITERABLE_TYPES</span><span class="p">):</span>

            <span class="c1"># can be an iterable of labels (keys) or an iterable of Booleans</span>
            <span class="c1"># if len(key) == len(label_to_pos) and isinstance(key[0], (bool, np.bool_)):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">key</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">positions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

            <span class="c1"># map labels to integer positions</span>
            <span class="c1"># NOTE: we miss the opportunity to get a reference from values when we have contiguous keys</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">label_to_pos</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">key</span><span class="p">]</span>

        <span class="c1"># if a single element (an integer, string, or date, we just get the integer out of the map</span>
        <span class="k">return</span> <span class="n">label_to_pos</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>



<span class="c1">#-------------------------------------------------------------------------------</span>

<div class="viewcode-block" id="Index"><a class="viewcode-back" href="../../../../overview.html#static_frame.Index">[docs]</a><span class="k">class</span> <span class="nc">Index</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">MetaOperatorDelegate</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;A mapping of labels to positions, immutable and of fixed size. Used in :py:class:`Series` and as index and columns in :py:class:`Frame`.</span>

<span class="sd">    Args:</span>
<span class="sd">        labels: the ordered keys to use as the index; can be a generator</span>
<span class="sd">        loc_is_iloc: optimization for when a contiguous integer idnex is provided as labels.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s1">&#39;_map&#39;</span><span class="p">,</span>
            <span class="s1">&#39;_labels&#39;</span><span class="p">,</span>
            <span class="s1">&#39;_positions&#39;</span><span class="p">,</span>
            <span class="s1">&#39;_recache&#39;</span><span class="p">,</span>
            <span class="s1">&#39;_loc_is_iloc&#39;</span><span class="p">,</span>
            <span class="s1">&#39;loc&#39;</span><span class="p">,</span>
            <span class="s1">&#39;iloc&#39;</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="c1">#---------------------------------------------------------------------------</span>
    <span class="c1"># methods used in __init__ that are customized in dervied classes; there, we need to mutate instance state, this these are instance methods</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_extract_labels</span><span class="p">(</span>
            <span class="n">mapping</span><span class="p">,</span>
            <span class="n">labels</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tp</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">tp</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">tp</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="n">tp</span><span class="o">.</span><span class="n">Any</span><span class="p">]]:</span>
        <span class="sd">&#39;&#39;&#39;Derive labels, a cache of the mapping keys in a sequence type (either an ndarray or a list).</span>

<span class="sd">        If the labels passed at instantiation are an ndarray, they are used after immutable filtering. Otherwise, the mapping keys are used to create an ndarray.</span>

<span class="sd">        This method is overridden in the derived class.</span>

<span class="sd">        Args:</span>
<span class="sd">            labels: might be an expired Generator, but if it is an immutable npdarry, we can use it without a copy</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># pre-fetching labels for faster get_item construction</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span> <span class="c1"># if an np array can handle directly</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">TypeBlocks</span><span class="o">.</span><span class="n">immutable_filter</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">):</span> <span class="c1"># not a generator, not an array</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
            <span class="n">labels</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># labels may be an expired generator</span>
            <span class="c1"># until all Python dictionaries are ordered, we cannot just take keys()</span>
            <span class="c1"># labels = np.array(tuple(mapping.keys()))</span>
            <span class="c1"># assume object type so as to not create a temporary list</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mapping</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">labels</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
            <span class="n">labels</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">labels</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_extract_positions</span><span class="p">(</span>
            <span class="n">mapping</span><span class="p">,</span>
            <span class="n">positions</span><span class="p">):</span>
        <span class="c1"># positions is either None or an ndarray</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span> <span class="c1"># if an np array can handle directly</span>
            <span class="k">return</span> <span class="n">TypeBlocks</span><span class="o">.</span><span class="n">immutable_filter</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mapping</span><span class="p">))</span>
        <span class="n">positions</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">positions</span>


    <span class="k">def</span> <span class="nf">_update_array_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Derived classes can use this to set stored arrays, self._labels and self._positions.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">pass</span>

    <span class="c1">#---------------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">labels</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Generator</span><span class="p">[</span><span class="n">tp</span><span class="o">.</span><span class="n">Hashable</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span>
            <span class="n">loc_is_iloc</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_recache</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">positions</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">labels</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
            <span class="c1"># get a reference to the immutable arrays</span>
            <span class="c1"># even if this is an IndexGO index, we can take the cached arrays, assuming they are up to date</span>
            <span class="k">if</span> <span class="n">labels</span><span class="o">.</span><span class="n">_recache</span><span class="p">:</span>
                <span class="n">labels</span><span class="o">.</span><span class="n">_update_array_cache</span><span class="p">()</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">_positions</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">_labels</span>

        <span class="c1"># map provided values to integer positions; do only one iteration of labels to support generators</span>
        <span class="c1"># collections.abs.sized</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">):</span>
            <span class="c1"># dict() function shown to be faster then gen expression</span>
            <span class="k">if</span> <span class="n">positions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">positions</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">))))</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># handle generators</span>
            <span class="c1"># dict() function shown slower in this case</span>
            <span class="c1"># self._map = dict((v, k) for k, v in enumerate(labels))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">labels</span><span class="p">)}</span>

        <span class="c1"># this might be NP array, or a list, depending on if static or grow only</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_labels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_map</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_positions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_positions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_map</span><span class="p">,</span> <span class="n">positions</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_loc_is_iloc</span> <span class="o">=</span> <span class="n">loc_is_iloc</span>

        <span class="c1"># NOTE:  automatic discovery is possible but not sure that the cost of a big comparison is worth it</span>
        <span class="c1"># if (self._labels.dtype == int</span>
        <span class="c1">#         and self._labels[0] == 0</span>
        <span class="c1">#         and self._labels[-1] == self._positions[-1]</span>
        <span class="c1">#         and (self._labels == self._positions).all()):</span>
        <span class="c1">#     self._loc_is_iloc = True</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_map</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;labels have non-unique values&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">loc</span> <span class="o">=</span> <span class="n">GetItem</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_extract_loc</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span> <span class="o">=</span> <span class="n">GetItem</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_extract_iloc</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">display</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">:</span> <span class="n">DisplayConfig</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Display</span><span class="p">:</span>
        <span class="n">config</span> <span class="o">=</span> <span class="n">config</span> <span class="ow">or</span> <span class="n">DisplayActive</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_array_cache</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">Display</span><span class="o">.</span><span class="n">from_values</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="n">header</span><span class="o">=</span><span class="s1">&#39;&lt;&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;&gt;&#39;</span><span class="p">,</span>
                <span class="n">config</span><span class="o">=</span><span class="n">config</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">())</span>


    <span class="k">def</span> <span class="nf">loc_to_iloc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">GetItemKeyType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">GetItemKeyType</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns:</span>
<span class="sd">            Return GetItemKey type that is based on integers, compatible with TypeBlocks</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">values</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_array_cache</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loc_is_iloc</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">key</span>

        <span class="k">return</span> <span class="n">LocMap</span><span class="o">.</span><span class="n">loc_to_iloc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_map</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_positions</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_array_cache</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;We iterate over labels.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_array_cache</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;Return True if value in the labels.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_map</span><span class="o">.</span><span class="fm">__contains__</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;Return the immutable labels array</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_array_cache</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mloc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Memory location</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_array_cache</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">mloc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Index&#39;</span><span class="p">:</span>
        <span class="c1"># this is not a complete deepcopy, as _labels here is an immutable np array (a new map will be created); if this is an IndexGO, we will pass the cached, immutable NP array</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_array_cache</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">)</span>


<div class="viewcode-block" id="Index.relabel"><a class="viewcode-back" href="../../../../overview.html#static_frame.Index.relabel">[docs]</a>    <span class="k">def</span> <span class="nf">relabel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapper</span><span class="p">:</span> <span class="n">CallableOrMapping</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Index&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a new Index with labels replaced by the callable or mapping; order will be retained. If a mapping is used, the mapping need not map all origin keys.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">mapper</span><span class="p">):</span>
            <span class="c1"># if a mapper, it must support both __getitem__ and __contains__</span>
            <span class="n">getitem</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="s1">&#39;__getitem__&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">getitem</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">mapper</span> <span class="k">else</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">mapper</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">)</span></div>

    <span class="c1">#---------------------------------------------------------------------------</span>
    <span class="c1"># set operations</span>

    <span class="k">def</span> <span class="nf">intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Index&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_array_cache</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">opperand</span> <span class="o">=</span> <span class="n">other</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># assume we can get it from a .values attribute</span>
            <span class="n">opperand</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">values</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">,</span> <span class="n">opperand</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Index&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_array_cache</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">opperand</span> <span class="o">=</span> <span class="n">other</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># assume we can get it from a .values attribute</span>
            <span class="n">opperand</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">values</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">union1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">,</span> <span class="n">opperand</span><span class="p">))</span>

    <span class="c1">#---------------------------------------------------------------------------</span>
    <span class="c1"># extraction and selection</span>

    <span class="k">def</span> <span class="nf">_extract_iloc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Index&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;Extract a new index given an iloc key</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_array_cache</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="c1"># if labels is an np array, this will be a view; if a list, a copy</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">_KEY_ITERABLE_TYPES</span><span class="p">):</span>
            <span class="c1"># we assume Booleans have been normalized to integers here</span>
            <span class="c1"># can select directly from _labels[key] if if key is a list</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># select a single label value</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="n">key</span><span class="p">],)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_extract_loc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">GetItemKeyType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Index&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_iloc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loc_to_iloc</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">GetItemKeyType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Index&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;Extract a new index given an iloc key (this is the same as Pandas).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_iloc</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="c1">#---------------------------------------------------------------------------</span>
    <span class="c1"># operators</span>

    <span class="k">def</span> <span class="nf">_ufunc_unary_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Callable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;Always return an NP array.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_array_cache</span><span class="p">()</span>

        <span class="n">array</span> <span class="o">=</span> <span class="n">operator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">)</span>
        <span class="n">array</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">array</span>

    <span class="k">def</span> <span class="nf">_ufunc_binary_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">operator</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Callable</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Binary operators applied to an index always return an NP array. This deviates from Pandas, where some operations (multipling an int index by an int) result in a new Index, while other operations result in a np.array (using == on two Index).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_array_cache</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">values</span> <span class="c1"># operate on labels to labels</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">operator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="n">array</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">array</span>


    <span class="k">def</span> <span class="nf">_ufunc_axis_skipna</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="p">,</span> <span class="n">ufunc</span><span class="p">,</span> <span class="n">ufunc_skipna</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Axis argument is required but is irrelevant.</span>

<span class="sd">        Args:</span>
<span class="sd">            dtype: Not used in 1D application, but collected here to provide a uniform signature.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">_ufunc_skipna_1d</span><span class="p">(</span>
                <span class="n">array</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">,</span>
                <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span>
                <span class="n">ufunc</span><span class="o">=</span><span class="n">ufunc</span><span class="p">,</span>
                <span class="n">ufunc_skipna</span><span class="o">=</span><span class="n">ufunc_skipna</span><span class="p">)</span>

    <span class="c1">#---------------------------------------------------------------------------</span>
    <span class="c1"># utility functions</span>

<div class="viewcode-block" id="Index.sort"><a class="viewcode-back" href="../../../../overview.html#static_frame.Index.sort">[docs]</a>    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">ascending</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="n">_DEFAULT_SORT_KIND</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Index&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;Return a new Index with the labels sorted.</span>

<span class="sd">        Args:</span>
<span class="sd">            kind: Sort algorithm passed to NumPy.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ascending</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">v</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="vm">__class__</span><span class="p">(</span><span class="n">v</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">isin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="n">tp</span><span class="o">.</span><span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;Return a Boolean array showing True where a label is found in other. If other is a multidimensional array, it is flattened.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_array_cache</span><span class="p">()</span>
        <span class="n">v</span><span class="p">,</span> <span class="n">assume_unique</span> <span class="o">=</span> <span class="n">_iterable_to_array</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="n">assume_unique</span><span class="p">)</span></div>


<div class="viewcode-block" id="IndexGO"><a class="viewcode-back" href="../../../../overview.html#static_frame.IndexGO">[docs]</a><span class="k">class</span> <span class="nc">IndexGO</span><span class="p">(</span><span class="n">Index</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A mapping of labels to positions, immutable with grow-only size. Used as columns in :py:class:`FrameGO`.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s1">&#39;_map&#39;</span><span class="p">,</span>
            <span class="s1">&#39;_labels_mutable&#39;</span><span class="p">,</span>
            <span class="s1">&#39;_positions_mutable_count&#39;</span><span class="p">,</span>
            <span class="s1">&#39;_labels&#39;</span><span class="p">,</span>
            <span class="s1">&#39;_positions&#39;</span><span class="p">,</span>
            <span class="s1">&#39;_recache&#39;</span><span class="p">,</span>
            <span class="s1">&#39;iloc&#39;</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_extract_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tp</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="n">tp</span><span class="o">.</span><span class="n">Any</span><span class="p">]:</span>
        <span class="sd">&#39;&#39;&#39;Called in Index.__init__(). This creates and populates mutable storage as a side effect of array derivation.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">IndexGO</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_extract_labels</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_labels_mutable</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">labels</span>

    <span class="k">def</span> <span class="nf">_extract_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">positions</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tp</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="n">tp</span><span class="o">.</span><span class="n">Any</span><span class="p">]:</span>
        <span class="sd">&#39;&#39;&#39;Called in Index.__init__(). This creates and populates mutable storage. This creates and populates mutable storage as a side effect of array derivation.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">IndexGO</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_extract_positions</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">positions</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_positions_mutable_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">positions</span>


    <span class="k">def</span> <span class="nf">_update_array_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># this might fail if a sequence is given as a label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_labels_mutable</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_positions_mutable_count</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_positions</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_recache</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1">#---------------------------------------------------------------------------</span>
    <span class="c1"># grow only mutation</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Add a value</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_map</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;duplicate key append attempted&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="c1"># the new value is the count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_map</span><span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_positions_mutable_count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_labels_mutable</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="c1"># check value before incrementing</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loc_is_iloc</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">value</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_positions_mutable_count</span><span class="p">:</span>
                <span class="k">pass</span> <span class="c1"># an increment that keeps loc is iloc relationship</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_loc_is_iloc</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_positions_mutable_count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_recache</span> <span class="o">=</span> <span class="kc">True</span>


    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">_KEY_ITERABLE_TYPES</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Add multiple values</span>
<span class="sd">        Args:</span>
<span class="sd">            values: can be a generator.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_map</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;duplicate key append attempted&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="c1"># might bet better performance by calling extend() on _positions and _labels</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></div>



<span class="c1">#-------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="Series"><a class="viewcode-back" href="../../../../overview.html#static_frame.Series">[docs]</a><span class="k">class</span> <span class="nc">Series</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">MetaOperatorDelegate</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A one-dimensional ordered, labelled collection, immutable and of fixed size.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s1">&#39;values&#39;</span><span class="p">,</span>
        <span class="s1">&#39;_index&#39;</span><span class="p">,</span>
        <span class="s1">&#39;iloc&#39;</span><span class="p">,</span>
        <span class="s1">&#39;loc&#39;</span><span class="p">,</span>
        <span class="s1">&#39;mask&#39;</span><span class="p">,</span>
        <span class="s1">&#39;masked_array&#39;</span><span class="p">,</span>
        <span class="s1">&#39;assign&#39;</span><span class="p">,</span>
        <span class="s1">&#39;iter_group&#39;</span><span class="p">,</span>
        <span class="s1">&#39;iter_group_items&#39;</span><span class="p">,</span>
        <span class="s1">&#39;iter_element&#39;</span><span class="p">,</span>
        <span class="s1">&#39;iter_element_items&#39;</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="Series.from_items"><a class="viewcode-back" href="../../../../overview.html#static_frame.Series.from_items">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_items</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">pairs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Series&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;Series constructor from an iterator or generator of pairs, where the first value is the index and the second value is the value.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">def</span> <span class="nf">values</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
                <span class="c1"># populate index as side effect of iterating values</span>
                <span class="n">index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">yield</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">values</span><span class="p">(),</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">own_index</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">):</span>
        <span class="c1">#-----------------------------------------------------------------------</span>
        <span class="c1"># values assignment</span>
        <span class="c1"># expose .values directly as it is immutable</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="c1"># not sure if we should sort; not sure what to do if index is provided</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;dictionary creation of Series is not supported; pass items to from_items&#39;</span><span class="p">)</span>
            <span class="c1"># TODO: not sure if we need to check __iter__ here</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">dtype</span> <span class="ow">and</span> <span class="n">dtype</span> <span class="o">!=</span> <span class="nb">object</span> <span class="ow">and</span> <span class="n">dtype</span> <span class="o">!=</span> <span class="nb">str</span>
                    <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="s1">&#39;__next__&#39;</span><span class="p">):</span> <span class="c1"># a generator-like</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># it must be a single item</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;cannot create a Series from a single item if passed index has no length.&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># is numpy</span>
            <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dtype</span> <span class="o">!=</span> <span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;type requested is not the type given&#39;</span><span class="p">)</span> <span class="c1"># what to do here?</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">TypeBlocks</span><span class="o">.</span><span class="n">immutable_filter</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

        <span class="c1">#-----------------------------------------------------------------------</span>
        <span class="c1"># index assignment</span>
        <span class="c1"># NOTE: this generally must be done after values assignment, as from_items needs a values generator to be exhausted before looking to values</span>

        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># create an integer index</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)),</span> <span class="n">loc_is_iloc</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">own_index</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="n">index</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">IndexGO</span><span class="p">):</span>
            <span class="c1"># if a grow only index need to make immutable</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
            <span class="c1"># do not make a copy of it is an immutable index</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="n">index</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># let index handle instantiation</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;values and index do not match length&#39;</span><span class="p">)</span>

        <span class="c1">#-----------------------------------------------------------------------</span>
        <span class="c1"># attributes</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">loc</span> <span class="o">=</span> <span class="n">GetItem</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_extract_loc</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span> <span class="o">=</span> <span class="n">GetItem</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_extract_iloc</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">ExtractInterface</span><span class="p">(</span>
                <span class="n">iloc</span><span class="o">=</span><span class="n">GetItem</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_extract_iloc_mask</span><span class="p">),</span>
                <span class="n">loc</span><span class="o">=</span><span class="n">GetItem</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_extract_loc_mask</span><span class="p">),</span>
                <span class="n">getitem</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_extract_loc_mask</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">masked_array</span> <span class="o">=</span> <span class="n">ExtractInterface</span><span class="p">(</span>
                <span class="n">iloc</span><span class="o">=</span><span class="n">GetItem</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_extract_iloc_masked_array</span><span class="p">),</span>
                <span class="n">loc</span><span class="o">=</span><span class="n">GetItem</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_extract_loc_masked_array</span><span class="p">),</span>
                <span class="n">getitem</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_extract_loc_masked_array</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">assign</span> <span class="o">=</span> <span class="n">ExtractInterface</span><span class="p">(</span>
                <span class="n">iloc</span><span class="o">=</span><span class="n">GetItem</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_extract_iloc_assign</span><span class="p">),</span>
                <span class="n">loc</span><span class="o">=</span><span class="n">GetItem</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_extract_loc_assign</span><span class="p">),</span>
                <span class="n">getitem</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_extract_loc_assign</span><span class="p">)</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">iter_group</span> <span class="o">=</span> <span class="n">IterNode</span><span class="p">(</span>
                <span class="n">container</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">function_items</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_axis_group_items</span><span class="p">,</span>
                <span class="n">function_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_axis_group</span><span class="p">,</span>
                <span class="n">yield_type</span><span class="o">=</span><span class="n">IterNodeType</span><span class="o">.</span><span class="n">VALUES</span>
                <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iter_group_items</span> <span class="o">=</span> <span class="n">IterNode</span><span class="p">(</span>
                <span class="n">container</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">function_items</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_axis_group_items</span><span class="p">,</span>
                <span class="n">function_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_axis_group</span><span class="p">,</span>
                <span class="n">yield_type</span><span class="o">=</span><span class="n">IterNodeType</span><span class="o">.</span><span class="n">ITEMS</span>
                <span class="p">)</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">iter_element</span> <span class="o">=</span> <span class="n">IterNode</span><span class="p">(</span>
                <span class="n">container</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">function_items</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_axis_element_items</span><span class="p">,</span>
                <span class="n">function_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_axis_element</span><span class="p">,</span>
                <span class="n">yield_type</span><span class="o">=</span><span class="n">IterNodeType</span><span class="o">.</span><span class="n">VALUES</span>
                <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iter_element_items</span> <span class="o">=</span> <span class="n">IterNode</span><span class="p">(</span>
                <span class="n">container</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">function_items</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_axis_element_items</span><span class="p">,</span>
                <span class="n">function_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_axis_element</span><span class="p">,</span>
                <span class="n">yield_type</span><span class="o">=</span><span class="n">IterNodeType</span><span class="o">.</span><span class="n">ITEMS</span>
                <span class="p">)</span>

    <span class="c1">#---------------------------------------------------------------------------</span>
    <span class="c1"># index manipulation</span>

<div class="viewcode-block" id="Series.reindex"><a class="viewcode-back" href="../../../../overview.html#static_frame.Series.reindex">[docs]</a>    <span class="k">def</span> <span class="nf">reindex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">index</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="n">Index</span><span class="p">,</span> <span class="n">tp</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="n">tp</span><span class="o">.</span><span class="n">Any</span><span class="p">]],</span>
            <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Series&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a new Series based on the passed index.</span>

<span class="sd">        Args:</span>
<span class="sd">            fill_value: attempted to be used, but may be coerced by the dtype of this Series. `</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># TODO: implement `method` argument with bfill, ffill options</span>

        <span class="c1"># always use the Index constructor for safe aliasing when possible</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="n">ic</span> <span class="o">=</span> <span class="n">IndexCorrespondence</span><span class="o">.</span><span class="n">from_correspondence</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ic</span><span class="o">.</span><span class="n">is_subset</span><span class="p">:</span> <span class="c1"># must have some common</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">ic</span><span class="o">.</span><span class="n">iloc_src</span><span class="p">],</span>
                    <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
                    <span class="n">own_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">values</span> <span class="o">=</span> <span class="n">_full_for_fill</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="n">fill_value</span><span class="p">)</span>

        <span class="c1"># if some intersection of values</span>
        <span class="k">if</span> <span class="n">ic</span><span class="o">.</span><span class="n">has_common</span><span class="p">:</span>
            <span class="n">values</span><span class="p">[</span><span class="n">ic</span><span class="o">.</span><span class="n">iloc_dst</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">ic</span><span class="o">.</span><span class="n">iloc_src</span><span class="p">]</span>

        <span class="c1"># make immutable so a copy is not made</span>
        <span class="n">values</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">values</span><span class="p">,</span>
                <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
                <span class="n">own_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="Series.relabel"><a class="viewcode-back" href="../../../../overview.html#static_frame.Series.relabel">[docs]</a>    <span class="k">def</span> <span class="nf">relabel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapper</span><span class="p">:</span> <span class="n">CallableOrMapping</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Series&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a new Series based on a mapping (or callable) from old to new index values.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="n">mapper</span><span class="p">),</span>
                <span class="n">own_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

    <span class="c1">#---------------------------------------------------------------------------</span>
    <span class="c1"># na handling</span>

<div class="viewcode-block" id="Series.isna"><a class="viewcode-back" href="../../../../overview.html#static_frame.Series.isna">[docs]</a>    <span class="k">def</span> <span class="nf">isna</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Series&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a same-indexed, Boolean Series indicating which values are NaN or None.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># consider returning self if not values.any()?</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">_isna</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="n">values</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">)</span></div>

<div class="viewcode-block" id="Series.notna"><a class="viewcode-back" href="../../../../overview.html#static_frame.Series.notna">[docs]</a>    <span class="k">def</span> <span class="nf">notna</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Series&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a same-indexed, Boolean Series indicating which values are NaN or None.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">_isna</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">))</span>
        <span class="n">values</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">)</span></div>

<div class="viewcode-block" id="Series.dropna"><a class="viewcode-back" href="../../../../overview.html#static_frame.Series.dropna">[docs]</a>    <span class="k">def</span> <span class="nf">dropna</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Series&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a new Series after removing values of NaN or None.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">sel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">_isna</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">sel</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">sel</span><span class="p">]</span>
        <span class="n">values</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">sel</span><span class="p">])</span></div>

<div class="viewcode-block" id="Series.fillna"><a class="viewcode-back" href="../../../../overview.html#static_frame.Series.fillna">[docs]</a>    <span class="k">def</span> <span class="nf">fillna</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Series&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;Return a new Series after replacing NaN or None values with the supplied value.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">sel</span> <span class="o">=</span> <span class="n">_isna</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">sel</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;cannot assign an array to fillna&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">value_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span>

        <span class="n">assigned_dtype</span> <span class="o">=</span> <span class="n">_resolve_dtype</span><span class="p">(</span><span class="n">value_dtype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">assigned_dtype</span><span class="p">:</span>
            <span class="n">assigned</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">assigned</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">assigned_dtype</span><span class="p">)</span>

        <span class="n">assigned</span><span class="p">[</span><span class="n">sel</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="n">assigned</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">assigned</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">)</span></div>

    <span class="c1">#---------------------------------------------------------------------------</span>
    <span class="c1"># operators</span>

    <span class="k">def</span> <span class="nf">_ufunc_unary_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Callable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Series&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">operator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_ufunc_binary_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">operator</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Callable</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Series&#39;</span><span class="p">:</span>

        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
            <span class="c1"># if indices are the same, we can simply set other to values and fallback on NP</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span> <span class="c1"># this is an array</span>
                <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">values</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
                <span class="c1"># now need to reindex the Series</span>
                <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
                <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>

        <span class="c1"># if its an np array, we simply fall back on np behavior</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Operator application to greater dimensionalities will result in an array with more than 1 dimension; it is not clear how such an array should be indexed.&#39;</span><span class="p">)</span>
        <span class="c1"># permit single value constants; not sure about filtering other types</span>

        <span class="c1"># we want the dtype to be the result of applying the operator; this happends by default</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">operator</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_ufunc_axis_skipna</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="p">,</span> <span class="n">ufunc</span><span class="p">,</span> <span class="n">ufunc_skipna</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;For a Series, all functions of this type reduce the single axis of the Series to 1d, so Index has no use here.</span>

<span class="sd">        Args:</span>
<span class="sd">            dtype: not used, part of signature for a commin interface</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># following pandas convention, we replace Nones with nans so that, if skipna is False, a None can cause a nan result</span>
        <span class="k">return</span> <span class="n">_ufunc_skipna_1d</span><span class="p">(</span>
                <span class="n">array</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span>
                <span class="n">ufunc</span><span class="o">=</span><span class="n">ufunc</span><span class="p">,</span>
                <span class="n">ufunc_skipna</span><span class="o">=</span><span class="n">ufunc_skipna</span><span class="p">)</span>

    <span class="c1">#---------------------------------------------------------------------------</span>
<div class="viewcode-block" id="Series.__len__"><a class="viewcode-back" href="../../../../overview.html#static_frame.Series.__len__">[docs]</a>    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;Length of values.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="fm">__len__</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">display</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">:</span> <span class="n">DisplayConfig</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Display</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;Return a Display of the Series.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">config</span> <span class="o">=</span> <span class="n">config</span> <span class="ow">or</span> <span class="n">DisplayActive</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>

        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">display</span><span class="p">(</span><span class="n">config</span><span class="o">=</span><span class="n">config</span><span class="p">)</span>
        <span class="n">d</span><span class="o">.</span><span class="n">append_display</span><span class="p">(</span><span class="n">Display</span><span class="o">.</span><span class="n">from_values</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="n">header</span><span class="o">=</span><span class="s1">&#39;&lt;&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;&gt;&#39;</span><span class="p">,</span>
                <span class="n">config</span><span class="o">=</span><span class="n">config</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">())</span>

    <span class="c1">#---------------------------------------------------------------------------</span>
    <span class="c1"># common attributes from the numpy array</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mloc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">mloc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ndim</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">size</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nbytes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">nbytes</span>

    <span class="c1">#---------------------------------------------------------------------------</span>
    <span class="c1"># extraction</span>

    <span class="k">def</span> <span class="nf">_extract_iloc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">GetItemKeyType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Series&#39;</span><span class="p">:</span>
        <span class="c1"># iterable selection should be handled by NP (but maybe not if a tuple)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_extract_loc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">GetItemKeyType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Series&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Compatibility:</span>
<span class="sd">            Pandas supports taking in iterables of keys, where some keys are not found in the index; a Series is returned as if a reindex operation was performed. This is undesirable. Better instead is to use reindex()</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">iloc_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">loc_to_iloc</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">iloc_key</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span> <span class="c1"># if we have a single element</span>
            <span class="k">return</span> <span class="n">values</span>
        <span class="c1"># this might create new index from iloc, and then createa another Index on Index __init__</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">iloc_key</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">GetItemKeyType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Series&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;A Loc selection (by index labels).</span>

<span class="sd">        Compatibility:</span>
<span class="sd">            Pandas supports using both loc and iloc style selections with the __getitem__ interface on Series. This is undesirable, so here we only expose the loc interface (making the Series dictionary like, but unlike the Index, where __getitem__ is an iloc).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_loc</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="c1">#---------------------------------------------------------------------------</span>
    <span class="c1"># utilites for alternate extraction: mask and assignment</span>

    <span class="k">def</span> <span class="nf">_extract_iloc_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">GetItemKeyType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Series&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;Produce a new boolean Series of the same shape, where the values selected via iloc selection are True.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">mask</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">mask</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># can pass self here as it is immutable (assuming index cannot change)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_extract_loc_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">GetItemKeyType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Series&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;Produce a new boolean Series of the same shape, where the values selected via loc selection are True.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">iloc_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">loc_to_iloc</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_iloc_mask</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">iloc_key</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_extract_iloc_masked_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">GetItemKeyType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MaskedArray</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;Produce a new boolean Series of the same shape, where the values selected via iloc selection are True.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_iloc_mask</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">MaskedArray</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_extract_loc_masked_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">GetItemKeyType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MaskedArray</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;Produce a new boolean Series of the same shape, where the values selected via loc selection are True.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">iloc_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">loc_to_iloc</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_iloc_masked_array</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">iloc_key</span><span class="p">)</span>

    <span class="c1">#---------------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">_extract_iloc_assign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">GetItemKeyType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;SeriesAssign&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">SeriesAssign</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">iloc_key</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_extract_loc_assign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">GetItemKeyType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;SeriesAssign&#39;</span><span class="p">:</span>
        <span class="n">iloc_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">loc_to_iloc</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">SeriesAssign</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">iloc_key</span><span class="o">=</span><span class="n">iloc_key</span><span class="p">)</span>

    <span class="c1">#---------------------------------------------------------------------------</span>
    <span class="c1"># axis functions</span>

    <span class="k">def</span> <span class="nf">_axis_group_items</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">groups</span><span class="p">,</span> <span class="n">locations</span> <span class="o">=</span> <span class="n">_array_to_groups_and_locations</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">groups</span><span class="p">):</span>
            <span class="n">selection</span> <span class="o">=</span> <span class="n">locations</span> <span class="o">==</span> <span class="n">idx</span>
            <span class="k">yield</span> <span class="n">g</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_iloc</span><span class="p">(</span><span class="n">selection</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_axis_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">yield from</span> <span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_axis_group_items</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_axis_element_items</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Generator of index, value pairs, equivalent to Series.items(). Rpeated to have a common signature as other axis functions.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_axis_element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">yield from</span> <span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_axis_element_items</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">))</span>

    <span class="c1">#---------------------------------------------------------------------------</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span>

    <span class="c1"># @index.setter</span>
    <span class="c1"># def index(self, value):</span>
    <span class="c1">#     if len(value) != len(self._index):</span>
    <span class="c1">#         raise Exception(&#39;new index must match length of old index&#39;)</span>
    <span class="c1">#     self._index = Index(value)</span>

    <span class="c1">#---------------------------------------------------------------------------</span>
    <span class="c1"># dictionary-like interface</span>

<div class="viewcode-block" id="Series.keys"><a class="viewcode-back" href="../../../../overview.html#static_frame.Series.keys">[docs]</a>    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Index</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Iterator of index labels.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span></div>

<div class="viewcode-block" id="Series.__iter__"><a class="viewcode-back" href="../../../../overview.html#static_frame.Series.__iter__">[docs]</a>    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Iterator of index labels, same as :py:meth:`Series.keys`.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">()</span></div>

<div class="viewcode-block" id="Series.__contains__"><a class="viewcode-back" href="../../../../overview.html#static_frame.Series.__contains__">[docs]</a>    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Inclusion of value in index labels.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="fm">__contains__</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="Series.items"><a class="viewcode-back" href="../../../../overview.html#static_frame.Series.items">[docs]</a>    <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tp</span><span class="o">.</span><span class="n">Generator</span><span class="p">[</span><span class="n">tp</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">tp</span><span class="o">.</span><span class="n">Any</span><span class="p">,</span> <span class="n">tp</span><span class="o">.</span><span class="n">Any</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&#39;&#39;&#39;Iterator of pairs of index label and value.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span></div>

<div class="viewcode-block" id="Series.get"><a class="viewcode-back" href="../../../../overview.html#static_frame.Series.get">[docs]</a>    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return the value found at the index key, else the default if the key is not found.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">default</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span></div>

    <span class="c1">#---------------------------------------------------------------------------</span>
    <span class="c1"># transformations resulting in the same dimensionality</span>

<div class="viewcode-block" id="Series.sort_index"><a class="viewcode-back" href="../../../../overview.html#static_frame.Series.sort_index">[docs]</a>    <span class="k">def</span> <span class="nf">sort_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">ascending</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="n">_DEFAULT_SORT_KIND</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Series&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a new Series ordered by the sorted Index.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># argsort lets us do the sort once and reuse the results</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ascending</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">index_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>
        <span class="n">index_values</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>
        <span class="n">values</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index_values</span><span class="p">)</span></div>

<div class="viewcode-block" id="Series.sort_values"><a class="viewcode-back" href="../../../../overview.html#static_frame.Series.sort_values">[docs]</a>    <span class="k">def</span> <span class="nf">sort_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">ascending</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="n">_DEFAULT_SORT_KIND</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Series&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a new Series ordered by the sorted values.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># argsort lets us do the sort once and reuse the results</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ascending</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">index_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>
        <span class="n">index_values</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>
        <span class="n">values</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index_values</span><span class="p">)</span></div>


<div class="viewcode-block" id="Series.isin"><a class="viewcode-back" href="../../../../overview.html#static_frame.Series.isin">[docs]</a>    <span class="k">def</span> <span class="nf">isin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Series&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a same-sized Boolean Series that shows if the same-positoined element is in the iterable passed to the function.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># cannot use assume_unique because do not know if values is unique</span>
        <span class="n">v</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_iterable_to_array</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="n">array</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">)</span></div>

<div class="viewcode-block" id="Series.transpose"><a class="viewcode-back" href="../../../../overview.html#static_frame.Series.transpose">[docs]</a>    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Series&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;The transpositon of a Series is itself.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">T</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>


<div class="viewcode-block" id="Series.duplicated"><a class="viewcode-back" href="../../../../overview.html#static_frame.Series.duplicated">[docs]</a>    <span class="k">def</span> <span class="nf">duplicated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">exclude_first</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">exclude_last</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a same-sized Boolean Series that shows True for all b values that are duplicated.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># TODO: might be able to do this witnout calling .values and passing in TypeBlocks, but TB needs to support roll</span>
        <span class="n">duplicates</span> <span class="o">=</span> <span class="n">_array_to_duplicated</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="n">exclude_first</span><span class="o">=</span><span class="n">exclude_first</span><span class="p">,</span>
                <span class="n">exclude_last</span><span class="o">=</span><span class="n">exclude_last</span><span class="p">)</span>
        <span class="n">duplicates</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">duplicates</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">)</span></div>

<div class="viewcode-block" id="Series.drop_duplicated"><a class="viewcode-back" href="../../../../overview.html#static_frame.Series.drop_duplicated">[docs]</a>    <span class="k">def</span> <span class="nf">drop_duplicated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">exclude_first</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">exclude_last</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a Series with duplicated values removed.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">duplicates</span> <span class="o">=</span> <span class="n">_array_to_duplicated</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="n">exclude_first</span><span class="o">=</span><span class="n">exclude_first</span><span class="p">,</span>
                <span class="n">exclude_last</span><span class="o">=</span><span class="n">exclude_last</span><span class="p">)</span>
        <span class="n">keep</span> <span class="o">=</span> <span class="o">~</span><span class="n">duplicates</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">keep</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">keep</span><span class="p">])</span></div>

    <span class="c1">#---------------------------------------------------------------------------</span>
    <span class="c1"># utility function to numpy array</span>

<div class="viewcode-block" id="Series.unique"><a class="viewcode-back" href="../../../../overview.html#static_frame.Series.unique">[docs]</a>    <span class="k">def</span> <span class="nf">unique</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a NumPy array of unqiue values.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span></div>

    <span class="c1">#---------------------------------------------------------------------------</span>
    <span class="c1"># export</span>

<div class="viewcode-block" id="Series.to_pairs"><a class="viewcode-back" href="../../../../overview.html#static_frame.Series.to_pairs">[docs]</a>    <span class="k">def</span> <span class="nf">to_pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tp</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="n">tp</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">tp</span><span class="o">.</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">tp</span><span class="o">.</span><span class="n">Any</span><span class="p">]]:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a tuple of tuples of index label, value.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">_labels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">))</span></div>

<div class="viewcode-block" id="Series.to_pandas"><a class="viewcode-back" href="../../../../overview.html#static_frame.Series.to_pandas">[docs]</a>    <span class="k">def</span> <span class="nf">to_pandas</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a Pandas Series.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">import</span> <span class="nn">pandas</span>
        <span class="k">return</span> <span class="n">pandas</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span></div></div>



<span class="k">class</span> <span class="nc">SeriesAssign</span><span class="p">:</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;iloc_key&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
            <span class="n">data</span><span class="p">:</span> <span class="n">Series</span><span class="p">,</span>
            <span class="n">iloc_key</span><span class="p">:</span> <span class="n">GetItemKeyType</span>
            <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iloc_key</span> <span class="o">=</span> <span class="n">iloc_key</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">array</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">iloc_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="n">array</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>



<span class="c1">#-------------------------------------------------------------------------------</span>


<span class="k">class</span> <span class="nc">IterNodeApplyType</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="n">SERIES_ITEMS</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">FRAME_ELEMENTS</span> <span class="o">=</span> <span class="mi">2</span>


<span class="k">class</span> <span class="nc">IterNodeType</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="n">VALUES</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">ITEMS</span> <span class="o">=</span> <span class="mi">2</span>


<div class="viewcode-block" id="IterNodeDelegate"><a class="viewcode-back" href="../../../../overview.html#static_frame.IterNodeDelegate">[docs]</a><span class="k">class</span> <span class="nc">IterNodeDelegate</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Delegate returned from :py:class:`IterNode`, providing iteration as well as a family of apply methods.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s1">&#39;_func_values&#39;</span><span class="p">,</span>
            <span class="s1">&#39;_func_items&#39;</span><span class="p">,</span>
            <span class="s1">&#39;_yield_type&#39;</span><span class="p">,</span>
            <span class="s1">&#39;_apply_constructor&#39;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">func_values</span><span class="p">,</span>
            <span class="n">func_items</span><span class="p">,</span>
            <span class="n">yield_type</span><span class="p">:</span> <span class="n">IterNodeType</span><span class="p">,</span>
            <span class="n">apply_constructor</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Args:</span>
<span class="sd">            apply_constructor: Callable (generally a class) used to construct the object returned from apply(); must take an iterator of items.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_func_values</span> <span class="o">=</span> <span class="n">func_values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_func_items</span><span class="o">=</span> <span class="n">func_items</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_yield_type</span> <span class="o">=</span> <span class="n">yield_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_constructor</span> <span class="o">=</span> <span class="n">apply_constructor</span>

    <span class="c1">#---------------------------------------------------------------------------</span>
    <span class="c1"># core methods are apply_iter_items, yielding pairs of key, value</span>

<div class="viewcode-block" id="IterNodeDelegate.apply_iter_items"><a class="viewcode-back" href="../../../../overview.html#static_frame.IterNodeDelegate.apply_iter_items">[docs]</a>    <span class="k">def</span> <span class="nf">apply_iter_items</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">func</span><span class="p">:</span> <span class="n">CallableOrMapping</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tp</span><span class="o">.</span><span class="n">Generator</span><span class="p">[</span><span class="n">tp</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">tp</span><span class="o">.</span><span class="n">Any</span><span class="p">,</span> <span class="n">tp</span><span class="o">.</span><span class="n">Any</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Generator that applies function to each element iterated and yields the pair of element and the result.</span>

<span class="sd">        Args:</span>
<span class="sd">            func: A function or a mapping object that defines __getitem__ and __contains__. If a mpping is given and a value is not found in the mapping, the value is returned unchanged (this deviates from Pandas Series.map, which inserts NaNs)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">condition</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
            <span class="c1"># if the key is not in the map, we return the value unaltered</span>
            <span class="n">condition</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s1">&#39;__contains__&#39;</span><span class="p">)</span>
            <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s1">&#39;__getitem__&#39;</span><span class="p">)</span>

        <span class="c1"># apply always calls the items function</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_func_items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">condition</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">condition</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_yield_type</span> <span class="ow">is</span> <span class="n">IterNodeType</span><span class="o">.</span><span class="n">VALUES</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># items, give both keys and values to function</span>
                    <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># depend on yield type, we determine what the passed in function expects to take</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_yield_type</span> <span class="ow">is</span> <span class="n">IterNodeType</span><span class="o">.</span><span class="n">VALUES</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">func</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># items, give both keys and values to function</span>
                    <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">func</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">apply_iter_items_parallel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">func</span><span class="p">:</span> <span class="n">CallableOrMapping</span><span class="p">,</span>
            <span class="n">max_workers</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
            <span class="n">chunksize</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
            <span class="n">use_threads</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tp</span><span class="o">.</span><span class="n">Generator</span><span class="p">[</span><span class="n">tp</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">tp</span><span class="o">.</span><span class="n">Any</span><span class="p">,</span> <span class="n">tp</span><span class="o">.</span><span class="n">Any</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>

        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Args:</span>
<span class="sd">            func: A function or a mapping object that defines __getitem__. If a mapping is given all values must be found in the mapping (this deviates from Pandas Series.map, which inserts NaNs)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">pool_executor</span> <span class="o">=</span> <span class="n">ThreadPoolExecutor</span> <span class="k">if</span> <span class="n">use_threads</span> <span class="k">else</span> <span class="n">ProcessPoolExecutor</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
            <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s1">&#39;__getitem__&#39;</span><span class="p">)</span>

        <span class="c1"># use side effect list population to create keys when iterating over values</span>
        <span class="n">func_keys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_yield_type</span> <span class="ow">is</span> <span class="n">IterNodeType</span><span class="o">.</span><span class="n">VALUES</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">arg_gen</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_func_items</span><span class="p">():</span>
                    <span class="n">func_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                    <span class="k">yield</span> <span class="n">v</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">arg_gen</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_func_items</span><span class="p">():</span>
                    <span class="n">func_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                    <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span>

        <span class="k">with</span> <span class="n">pool_executor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="n">max_workers</span><span class="p">)</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
            <span class="k">yield from</span> <span class="nb">zip</span><span class="p">(</span><span class="n">func_keys</span><span class="p">,</span>
                    <span class="n">executor</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">arg_gen</span><span class="p">(),</span> <span class="n">chunksize</span><span class="o">=</span><span class="n">chunksize</span><span class="p">)</span>
                    <span class="p">)</span>

    <span class="c1">#---------------------------------------------------------------------------</span>
    <span class="c1"># utility interfaces</span>

<div class="viewcode-block" id="IterNodeDelegate.apply_iter"><a class="viewcode-back" href="../../../../overview.html#static_frame.IterNodeDelegate.apply_iter">[docs]</a>    <span class="k">def</span> <span class="nf">apply_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">func</span><span class="p">:</span> <span class="n">CallableOrMapping</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tp</span><span class="o">.</span><span class="n">Generator</span><span class="p">[</span><span class="n">tp</span><span class="o">.</span><span class="n">Any</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Generator that applies the passed function to each element iterated and yields the result.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">yield from</span> <span class="p">(</span><span class="n">v</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_iter_items</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">))</span></div>


<div class="viewcode-block" id="IterNodeDelegate.apply"><a class="viewcode-back" href="../../../../overview.html#static_frame.IterNodeDelegate.apply">[docs]</a>    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">func</span><span class="p">:</span> <span class="n">CallableOrMapping</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">max_workers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">chunksize</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
            <span class="n">use_threads</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tp</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="n">Series</span><span class="p">,</span> <span class="s1">&#39;Frame&#39;</span><span class="p">]:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Apply passed function to each object iterated, where the object depends on the creation of this instance.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">max_workers</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_constructor</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">apply_iter_items_parallel</span><span class="p">(</span>
                            <span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">,</span>
                            <span class="n">max_workers</span><span class="o">=</span><span class="n">max_workers</span><span class="p">,</span>
                            <span class="n">chunksize</span><span class="o">=</span><span class="n">chunksize</span><span class="p">,</span>
                            <span class="n">use_threads</span><span class="o">=</span><span class="n">use_threads</span><span class="p">),</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_constructor</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">apply_iter_items</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span></div>

<div class="viewcode-block" id="IterNodeDelegate.__iter__"><a class="viewcode-back" href="../../../../overview.html#static_frame.IterNodeDelegate.__iter__">[docs]</a>    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a generator based on the yield type.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_yield_type</span> <span class="ow">is</span> <span class="n">IterNodeType</span><span class="o">.</span><span class="n">VALUES</span><span class="p">:</span>
            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_func_values</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_func_items</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="IterNode"><a class="viewcode-back" href="../../../../overview.html#static_frame.IterNode">[docs]</a><span class="k">class</span> <span class="nc">IterNode</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;Iterface to a type of iteration on :py:class:`Series` and :py:class:`Frame`.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># &#39;&#39;&#39;Stores two version of a generator function: one to yield single values, another to yield items pairs. The latter is needed in all cases, as when we use apply we return a Series, and need to have recourse to an index.</span>
    <span class="c1"># &#39;&#39;&#39;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;_container&#39;</span><span class="p">,</span>
            <span class="s1">&#39;_func_values&#39;</span><span class="p">,</span>
            <span class="s1">&#39;_func_items&#39;</span><span class="p">,</span>
            <span class="s1">&#39;_yield_type&#39;</span><span class="p">,</span>
            <span class="s1">&#39;_apply_type&#39;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
            <span class="n">container</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="n">Series</span><span class="p">,</span> <span class="s1">&#39;Frame&#39;</span><span class="p">],</span>
            <span class="n">function_values</span><span class="p">,</span>
            <span class="n">function_items</span><span class="p">,</span>
            <span class="n">yield_type</span><span class="p">:</span> <span class="n">IterNodeType</span><span class="p">,</span>
            <span class="n">apply_type</span><span class="p">:</span> <span class="n">IterNodeApplyType</span><span class="o">=</span><span class="n">IterNodeApplyType</span><span class="o">.</span><span class="n">SERIES_ITEMS</span>
            <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_container</span> <span class="o">=</span> <span class="n">container</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_func_values</span> <span class="o">=</span> <span class="n">function_values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_func_items</span> <span class="o">=</span> <span class="n">function_items</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_yield_type</span> <span class="o">=</span> <span class="n">yield_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_type</span> <span class="o">=</span> <span class="n">apply_type</span>

        <span class="c1"># if function_type is IterNodeType.VALUES:</span>
        <span class="c1">#     self._func_values = function</span>

        <span class="c1">#     def func_items(*args, **kwargs):</span>
        <span class="c1">#         if not kwargs and len(args) == 1:</span>
        <span class="c1">#             axis = args[0]</span>
        <span class="c1">#         else:</span>
        <span class="c1">#             axis = kwargs[&#39;axis&#39;]</span>

        <span class="c1">#         keys = self._container._index if axis == 1 else self._container._columns</span>
        <span class="c1">#         yield from zip(keys, function(*args, **kwargs))</span>

        <span class="c1">#     self._func_items = func_items</span>

        <span class="c1"># elif function_type is IterNodeType.ITEMS:</span>
        <span class="c1">#     self._func_items = function</span>

        <span class="c1">#     def func_values(*args, **kwargs):</span>
        <span class="c1">#         yield from (v for _, v in function(*args, **kwargs))</span>

        <span class="c1">#     self._func_values = func_values</span>
        <span class="c1"># else:</span>
        <span class="c1">#     raise NotImplementedError()</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        In usage as an iteator, the args passed here are expected to be argument for the core iterators, i.e., axis arguments.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">func_values</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_func_values</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">func_items</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_func_items</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_type</span> <span class="ow">is</span> <span class="n">IterNodeApplyType</span><span class="o">.</span><span class="n">SERIES_ITEMS</span><span class="p">:</span>
            <span class="n">apply_constructor</span> <span class="o">=</span> <span class="n">Series</span><span class="o">.</span><span class="n">from_items</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_type</span> <span class="ow">is</span> <span class="n">IterNodeApplyType</span><span class="o">.</span><span class="n">FRAME_ELEMENTS</span><span class="p">:</span>
            <span class="n">apply_constructor</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">Frame</span><span class="o">.</span><span class="n">from_element_loc_items</span><span class="p">,</span>
                    <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_container</span><span class="o">.</span><span class="n">_index</span><span class="p">,</span>
                    <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_container</span><span class="o">.</span><span class="n">_columns</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">IterNodeDelegate</span><span class="p">(</span>
                <span class="n">func_values</span><span class="o">=</span><span class="n">func_values</span><span class="p">,</span>
                <span class="n">func_items</span><span class="o">=</span><span class="n">func_items</span><span class="p">,</span>
                <span class="n">yield_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_yield_type</span><span class="p">,</span>
                <span class="n">apply_constructor</span><span class="o">=</span><span class="n">apply_constructor</span>
                <span class="p">)</span></div>


<div class="viewcode-block" id="Frame"><a class="viewcode-back" href="../../../../overview.html#static_frame.Frame">[docs]</a><span class="k">class</span> <span class="nc">Frame</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">MetaOperatorDelegate</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A two-dimensional ordered, labelled collection, immutable and of fixed size.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s1">&#39;_blocks&#39;</span><span class="p">,</span>
            <span class="s1">&#39;_columns&#39;</span><span class="p">,</span>
            <span class="s1">&#39;_index&#39;</span><span class="p">,</span>
            <span class="s1">&#39;iloc&#39;</span><span class="p">,</span>
            <span class="s1">&#39;loc&#39;</span><span class="p">,</span>
            <span class="s1">&#39;mask&#39;</span><span class="p">,</span>
            <span class="s1">&#39;masked_array&#39;</span><span class="p">,</span>
            <span class="s1">&#39;assign&#39;</span><span class="p">,</span>
            <span class="s1">&#39;iter_array&#39;</span><span class="p">,</span>
            <span class="s1">&#39;iter_array_items&#39;</span><span class="p">,</span>
            <span class="s1">&#39;iter_tuple&#39;</span><span class="p">,</span>
            <span class="s1">&#39;iter_tuple_items&#39;</span><span class="p">,</span>
            <span class="s1">&#39;iter_series&#39;</span><span class="p">,</span>
            <span class="s1">&#39;iter_series_items&#39;</span><span class="p">,</span>
            <span class="s1">&#39;iter_group&#39;</span><span class="p">,</span>
            <span class="s1">&#39;iter_group_items&#39;</span><span class="p">,</span>
            <span class="s1">&#39;iter_element&#39;</span><span class="p">,</span>
            <span class="s1">&#39;iter_element_items&#39;</span>
            <span class="p">)</span>

    <span class="n">_COLUMN_CONSTRUCTOR</span> <span class="o">=</span> <span class="n">Index</span>


<div class="viewcode-block" id="Frame.from_concat"><a class="viewcode-back" href="../../../../overview.html#static_frame.Frame.from_concat">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_concat</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span>
            <span class="n">frames</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="s1">&#39;Frame&#39;</span><span class="p">],</span>
            <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">union</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Concatenate multiple Frames into a new Frame. If index or columns are provided and appropriately sized, the resulting Frame will have those indices. If the axis along concatenation (index for axis 0, columns for axis 1) is unique after concatenation, it will be preserved.</span>

<span class="sd">        Args:</span>
<span class="sd">            frames: Iterable of Frames.</span>
<span class="sd">            axis: 0 stacks vertically, 1 stacks horizontally</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># TODO: should this upport Series?</span>

        <span class="k">if</span> <span class="n">union</span><span class="p">:</span>
            <span class="n">ufunc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">union1d</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ufunc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># index can be the same, columns must be redefined if not unique</span>
            <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># if these are different types unexpected things could happen</span>
                <span class="n">columns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">frame</span><span class="o">.</span><span class="n">_columns</span><span class="o">.</span><span class="n">values</span> <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="n">frames</span><span class="p">])</span>
                <span class="n">columns</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">columns</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Column names after concatenation are not unique; supply a columns argument.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">_array_set_ufunc_many</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">values</span> <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="n">frames</span><span class="p">),</span>
                        <span class="n">ufunc</span><span class="o">=</span><span class="n">ufunc</span><span class="p">)</span>
                <span class="n">index</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">def</span> <span class="nf">blocks</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="n">frames</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">index</span> <span class="o">!=</span> <span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="n">frame</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">frame</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">_blocks</span><span class="p">:</span>
                        <span class="k">yield</span> <span class="n">block</span>

            <span class="n">blocks</span> <span class="o">=</span> <span class="n">TypeBlocks</span><span class="o">.</span><span class="n">from_blocks</span><span class="p">(</span><span class="n">blocks</span><span class="p">())</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">blocks</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span> <span class="n">own_data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># if these are different types unexpected things could happen</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">frame</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">values</span> <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="n">frames</span><span class="p">])</span>
                <span class="n">index</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">index</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Index names after concatenation are not unique; supply an index argument.&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">columns</span> <span class="o">=</span> <span class="n">_array_set_ufunc_many</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">_columns</span><span class="o">.</span><span class="n">values</span> <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="n">frames</span><span class="p">),</span>
                        <span class="n">ufunc</span><span class="o">=</span><span class="n">ufunc</span><span class="p">)</span>
                <span class="n">columns</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">def</span> <span class="nf">blocks</span><span class="p">():</span>
                <span class="n">aligned_frames</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">previous_frame</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">block_compatible</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">reblock_compatible</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="n">frames</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">columns</span> <span class="o">!=</span> <span class="n">columns</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="n">frame</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>
                    <span class="n">aligned_frames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
                    <span class="c1"># column size is all the same by this point</span>
                    <span class="c1"># NOTE: this could be implemented on TypeBlock as a vstack opperations</span>
                    <span class="k">if</span> <span class="n">previous_frame</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">block_compatible</span><span class="p">:</span>
                            <span class="n">block_compatible</span> <span class="o">&amp;=</span> <span class="n">frame</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">block_compatible</span><span class="p">(</span>
                                    <span class="n">previous_frame</span><span class="o">.</span><span class="n">_blocks</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">reblock_compatible</span><span class="p">:</span>
                            <span class="n">reblock_compatible</span> <span class="o">&amp;=</span> <span class="n">frame</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">reblock_compatible</span><span class="p">(</span>
                                    <span class="n">previous_frame</span><span class="o">.</span><span class="n">_blocks</span><span class="p">)</span>
                    <span class="n">previous_frame</span> <span class="o">=</span> <span class="n">frame</span>

                <span class="k">if</span> <span class="n">block_compatible</span> <span class="ow">or</span> <span class="n">reblock_compatible</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">block_compatible</span> <span class="ow">and</span> <span class="n">reblock_compatible</span><span class="p">:</span>
                        <span class="n">type_blocks</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">consolidate</span><span class="p">()</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">aligned_frames</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">type_blocks</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">_blocks</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">aligned_frames</span><span class="p">]</span>

                    <span class="c1"># all TypeBlocks have the same number of blocks by here</span>
                    <span class="k">for</span> <span class="n">block_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">type_blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_blocks</span><span class="p">)):</span>
                        <span class="n">block_parts</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">frame_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">type_blocks</span><span class="p">)):</span>
                            <span class="n">b</span> <span class="o">=</span> <span class="n">TypeBlocks</span><span class="o">.</span><span class="n">single_column_filter</span><span class="p">(</span>
                                    <span class="n">type_blocks</span><span class="p">[</span><span class="n">frame_idx</span><span class="p">]</span><span class="o">.</span><span class="n">_blocks</span><span class="p">[</span><span class="n">block_idx</span><span class="p">])</span>
                            <span class="n">block_parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                        <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">block_parts</span><span class="p">)</span>
                        <span class="n">array</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">yield</span> <span class="n">array</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># must just combine .values</span>
                    <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">values</span> <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="n">frames</span><span class="p">)</span>
                    <span class="n">array</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">yield</span> <span class="n">array</span>

            <span class="n">blocks</span> <span class="o">=</span> <span class="n">TypeBlocks</span><span class="o">.</span><span class="n">from_blocks</span><span class="p">(</span><span class="n">blocks</span><span class="p">())</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">blocks</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span> <span class="n">own_data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;no support for axis&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span></div>

<div class="viewcode-block" id="Frame.from_records"><a class="viewcode-back" href="../../../../overview.html#static_frame.Frame.from_records">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_records</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span>
            <span class="n">records</span><span class="p">,</span>
            <span class="o">*</span><span class="p">,</span>
            <span class="n">index</span><span class="p">,</span>
            <span class="n">columns</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Frame constructor from an iterable of rows.</span>

<span class="sd">        Args:</span>
<span class="sd">            records: Iterable of row values.</span>
<span class="sd">            index: Iterable of index labels, equal in length to the number of records.</span>
<span class="sd">            columns: Iterable of column labels, equal in length to the length of each row.s</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># derive_columns = False</span>
        <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># derive_columns = True</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># TODO: not sure if this works</span>

        <span class="c1"># if records is np; we can just pass it to constructor, as is alrady a consolidate type</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">records</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">records</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">blocks</span><span class="p">():</span>
            <span class="n">rows</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">records</span><span class="p">)</span>
            <span class="c1"># derive types form first rows, but cannot do strings</span>
            <span class="c1"># string type requires size, so cannot use np.fromiter</span>
            <span class="n">types</span> <span class="o">=</span> <span class="p">[(</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">row_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rows</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                <span class="n">column_type</span> <span class="o">=</span> <span class="n">types</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">column_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">row</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span>
                            <span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">),</span>
                            <span class="n">count</span><span class="o">=</span><span class="n">row_count</span><span class="p">,</span>
                            <span class="n">dtype</span><span class="o">=</span><span class="n">column_type</span><span class="p">)</span>
                <span class="n">values</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">yield</span> <span class="n">values</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">TypeBlocks</span><span class="o">.</span><span class="n">from_blocks</span><span class="p">(</span><span class="n">TypeBlocks</span><span class="o">.</span><span class="n">consolidate_blocks</span><span class="p">(</span><span class="n">blocks</span><span class="p">())),</span>
                <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
                <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span>
                <span class="n">own_data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="Frame.from_items"><a class="viewcode-back" href="../../../../overview.html#static_frame.Frame.from_items">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_items</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span>
            <span class="n">pairs</span><span class="p">,</span>
            <span class="o">*</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Frame constructor from an iterator or generator of pairs, where the first value is the column name and the second value an iterable of column values.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">def</span> <span class="nf">blocks</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
                <span class="n">columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="c1"># side effet of generator!</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s1">&#39;values&#39;</span><span class="p">):</span> <span class="c1"># its could be Series or Frame</span>
                    <span class="n">values</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">values</span>
                    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
                    <span class="k">yield</span> <span class="n">values</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">v</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                    <span class="n">values</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">yield</span> <span class="n">values</span>


        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">TypeBlocks</span><span class="o">.</span><span class="n">from_blocks</span><span class="p">(</span><span class="n">TypeBlocks</span><span class="o">.</span><span class="n">consolidate_blocks</span><span class="p">(</span><span class="n">blocks</span><span class="p">())),</span>
                <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
                <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span>
                <span class="n">own_data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_structured_array</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span>
            <span class="n">array</span><span class="p">,</span>
            <span class="o">*</span><span class="p">,</span>
            <span class="n">index_column</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">tp</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Frame&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Convert a NumPy structed array into Frame.</span>

<span class="sd">        Args:</span>
<span class="sd">            index_column: optionally provide the name or position offset of the column to use as the index.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">names</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index_column</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">index_name</span> <span class="o">=</span> <span class="n">names</span><span class="p">[</span><span class="n">index_column</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index_name</span> <span class="o">=</span> <span class="n">index_column</span>

        <span class="c1"># assign in generator; requires  reading through gen first</span>
        <span class="n">index_array</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># cannot use names of we remove an index; might be a more efficient way as we kmnow the size</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">def</span> <span class="nf">blocks</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="n">index_name</span><span class="p">:</span>
                    <span class="k">nonlocal</span> <span class="n">index_array</span>
                    <span class="n">index_array</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                    <span class="k">continue</span>
                <span class="n">columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="c1"># this is not expected to make a copy</span>
                <span class="k">yield</span> <span class="n">array</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">TypeBlocks</span><span class="o">.</span><span class="n">from_blocks</span><span class="p">(</span><span class="n">TypeBlocks</span><span class="o">.</span><span class="n">consolidate_blocks</span><span class="p">(</span><span class="n">blocks</span><span class="p">())),</span>
                <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span>
                <span class="n">index</span><span class="o">=</span><span class="n">index_array</span><span class="p">,</span>
                <span class="n">own_data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_element_iloc_items</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span>
            <span class="n">items</span><span class="p">,</span>
            <span class="o">*</span><span class="p">,</span>
            <span class="n">index</span><span class="p">,</span>
            <span class="n">columns</span><span class="p">,</span>
            <span class="n">dtype</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Given an iterable of pairs of iloc coordinates and values, populate a Frame as defined by the given index and columns. Dtype must be specified.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_COLUMN_CONSTRUCTOR</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span>
        <span class="n">tb</span> <span class="o">=</span> <span class="n">TypeBlocks</span><span class="o">.</span><span class="n">from_element_items</span><span class="p">(</span><span class="n">items</span><span class="p">,</span>
                <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">)),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span>
                <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
                <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span>
                <span class="n">own_data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">own_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">own_columns</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_element_loc_items</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span>
            <span class="n">items</span><span class="p">,</span>
            <span class="o">*</span><span class="p">,</span>
            <span class="n">index</span><span class="p">,</span>
            <span class="n">columns</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_COLUMN_CONSTRUCTOR</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span>
        <span class="n">items</span> <span class="o">=</span> <span class="p">(((</span><span class="n">index</span><span class="o">.</span><span class="n">loc_to_iloc</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">columns</span><span class="o">.</span><span class="n">loc_to_iloc</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="n">v</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">items</span><span class="p">)</span>

        <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span> <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">object</span>
        <span class="n">tb</span> <span class="o">=</span> <span class="n">TypeBlocks</span><span class="o">.</span><span class="n">from_element_items</span><span class="p">(</span><span class="n">items</span><span class="p">,</span>
                <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">)),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span>
                <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
                <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span>
                <span class="n">own_data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">own_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">own_columns</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<div class="viewcode-block" id="Frame.from_csv"><a class="viewcode-back" href="../../../../overview.html#static_frame.Frame.from_csv">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_csv</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span>
            <span class="n">fp</span><span class="p">:</span> <span class="n">FilePathOrFileLike</span><span class="p">,</span>
            <span class="o">*</span><span class="p">,</span>
            <span class="n">sep</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span>
            <span class="n">index_column</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">tp</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">skip_header</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">skip_footer</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">header_is_columns</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">encoding</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Frame&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Args:</span>
<span class="sd">            header_is_columns: if True, field names are read from the first line after the first skip_header lines</span>
<span class="sd">            dtype: set to None by default to permit discovery</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># https://docs.scipy.org/doc/numpy/reference/generated/numpy.loadtxt.html</span>
        <span class="c1"># https://docs.scipy.org/doc/numpy/reference/generated/numpy.genfromtxt.html</span>

        <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span>
                <span class="n">delimiter</span><span class="o">=</span><span class="n">sep</span><span class="p">,</span>
                <span class="n">skip_header</span><span class="o">=</span><span class="n">skip_header</span><span class="p">,</span>
                <span class="n">skip_footer</span><span class="o">=</span><span class="n">skip_footer</span><span class="p">,</span>
                <span class="n">names</span><span class="o">=</span><span class="n">header_is_columns</span><span class="p">,</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
                <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span>
                <span class="p">)</span>
        <span class="c1"># can own this array so set it as immutable</span>
        <span class="n">array</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_structured_array</span><span class="p">(</span><span class="n">array</span><span class="p">,</span>
                <span class="n">index_column</span><span class="o">=</span><span class="n">index_column</span><span class="p">,</span>
                <span class="p">)</span></div>

<div class="viewcode-block" id="Frame.from_tsv"><a class="viewcode-back" href="../../../../overview.html#static_frame.Frame.from_tsv">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_tsv</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_csv</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="c1">#---------------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="o">*</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">own_data</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">own_index</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">own_columns</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Args:</span>
<span class="sd">            own_data: if True, assume that the data being based in can be owned entirely by this Frame; that is, that a copy does not need to made.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;To create a Frame form a dictionary-like object, use from_items()&#39;</span><span class="p">)</span>

        <span class="c1"># derive_columns = False # get from data</span>
        <span class="c1"># if columns is None:</span>
        <span class="c1">#     derive_columns = True</span>
        <span class="c1">#     columns = []</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">TypeBlocks</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">own_data</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span> <span class="o">=</span> <span class="n">data</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># assume we need to create a new TB instance; this will not copy underlying arrays as all blocks are immutable</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span> <span class="o">=</span> <span class="n">TypeBlocks</span><span class="o">.</span><span class="n">from_blocks</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">_blocks</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">blocks</span><span class="p">():</span>
                <span class="c1"># need to identify Series-like things and handle as single column</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;ndim&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># if derive_columns:</span>
                    <span class="c1">#     if hasattr(data, &#39;name&#39;) and data.name:</span>
                    <span class="c1">#         columns.append(data.name)</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="s1">&#39;values&#39;</span><span class="p">):</span>
                        <span class="k">yield</span> <span class="n">data</span><span class="o">.</span><span class="n">values</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">yield</span> <span class="n">data</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">own_data</span><span class="p">:</span>
                        <span class="n">data</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">yield</span> <span class="n">data</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># try to make it into array</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                    <span class="n">a</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">yield</span> <span class="n">a</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span> <span class="o">=</span> <span class="n">TypeBlocks</span><span class="o">.</span><span class="n">from_blocks</span><span class="p">(</span><span class="n">blocks</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># will have shape of 0,0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span> <span class="o">=</span> <span class="n">TypeBlocks</span><span class="o">.</span><span class="n">from_none</span><span class="p">()</span>

        <span class="n">row_count</span><span class="p">,</span> <span class="n">col_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># columns could be an np array, or an Index instance</span>
        <span class="k">if</span> <span class="n">own_columns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span> <span class="o">=</span> <span class="n">columns</span>
        <span class="k">elif</span> <span class="n">columns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_COLUMN_CONSTRUCTOR</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_COLUMN_CONSTRUCTOR</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">col_count</span><span class="p">),</span>
                    <span class="n">loc_is_iloc</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="p">)</span> <span class="o">!=</span> <span class="n">col_count</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;columns provided do not have correct size&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">own_index</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="n">index</span>
        <span class="k">elif</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">row_count</span><span class="p">),</span>
                    <span class="n">loc_is_iloc</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># permit bypassing this check if the row_count is zero</span>
        <span class="k">if</span> <span class="n">row_count</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">)</span> <span class="o">!=</span> <span class="n">row_count</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;index provided do not have correct size&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">loc</span> <span class="o">=</span> <span class="n">GetItem</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_extract_loc</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span> <span class="o">=</span> <span class="n">GetItem</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_extract_iloc</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">ExtractInterface</span><span class="p">(</span>
                <span class="n">iloc</span><span class="o">=</span><span class="n">GetItem</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_extract_iloc_mask</span><span class="p">),</span>
                <span class="n">loc</span><span class="o">=</span><span class="n">GetItem</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_extract_loc_mask</span><span class="p">),</span>
                <span class="n">getitem</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_extract_getitem_mask</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">masked_array</span> <span class="o">=</span> <span class="n">ExtractInterface</span><span class="p">(</span>
                <span class="n">iloc</span><span class="o">=</span><span class="n">GetItem</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_extract_iloc_masked_array</span><span class="p">),</span>
                <span class="n">loc</span><span class="o">=</span><span class="n">GetItem</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_extract_loc_masked_array</span><span class="p">),</span>
                <span class="n">getitem</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_extract_getitem_masked_array</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">assign</span> <span class="o">=</span> <span class="n">ExtractInterface</span><span class="p">(</span>
                <span class="n">iloc</span><span class="o">=</span><span class="n">GetItem</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_extract_iloc_assign</span><span class="p">),</span>
                <span class="n">loc</span><span class="o">=</span><span class="n">GetItem</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_extract_loc_assign</span><span class="p">),</span>
                <span class="n">getitem</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_extract_getitem_assign</span><span class="p">)</span>

        <span class="c1"># generators</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iter_array</span> <span class="o">=</span> <span class="n">IterNode</span><span class="p">(</span>
                <span class="n">container</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">function_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_axis_array</span><span class="p">,</span>
                <span class="n">function_items</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_axis_array_items</span><span class="p">,</span>
                <span class="n">yield_type</span><span class="o">=</span><span class="n">IterNodeType</span><span class="o">.</span><span class="n">VALUES</span>
                <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iter_array_items</span> <span class="o">=</span> <span class="n">IterNode</span><span class="p">(</span>
                <span class="n">container</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">function_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_axis_array</span><span class="p">,</span>
                <span class="n">function_items</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_axis_array_items</span><span class="p">,</span>
                <span class="n">yield_type</span><span class="o">=</span><span class="n">IterNodeType</span><span class="o">.</span><span class="n">ITEMS</span>
                <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">iter_tuple</span> <span class="o">=</span> <span class="n">IterNode</span><span class="p">(</span>
                <span class="n">container</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">function_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_axis_tuple</span><span class="p">,</span>
                <span class="n">function_items</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_axis_tuple_items</span><span class="p">,</span>
                <span class="n">yield_type</span><span class="o">=</span><span class="n">IterNodeType</span><span class="o">.</span><span class="n">VALUES</span>
                <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iter_tuple_items</span> <span class="o">=</span> <span class="n">IterNode</span><span class="p">(</span>
                <span class="n">container</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">function_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_axis_tuple</span><span class="p">,</span>
                <span class="n">function_items</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_axis_tuple_items</span><span class="p">,</span>
                <span class="n">yield_type</span><span class="o">=</span><span class="n">IterNodeType</span><span class="o">.</span><span class="n">ITEMS</span>
                <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">iter_series</span> <span class="o">=</span> <span class="n">IterNode</span><span class="p">(</span>
                <span class="n">container</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">function_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_axis_series</span><span class="p">,</span>
                <span class="n">function_items</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_axis_series_items</span><span class="p">,</span>
                <span class="n">yield_type</span><span class="o">=</span><span class="n">IterNodeType</span><span class="o">.</span><span class="n">VALUES</span>
                <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iter_series_items</span> <span class="o">=</span> <span class="n">IterNode</span><span class="p">(</span>
                <span class="n">container</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">function_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_axis_series</span><span class="p">,</span>
                <span class="n">function_items</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_axis_series_items</span><span class="p">,</span>
                <span class="n">yield_type</span><span class="o">=</span><span class="n">IterNodeType</span><span class="o">.</span><span class="n">ITEMS</span>
                <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">iter_group</span> <span class="o">=</span> <span class="n">IterNode</span><span class="p">(</span>
                <span class="n">container</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">function_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_axis_group_loc</span><span class="p">,</span>
                <span class="n">function_items</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_axis_group_loc_items</span><span class="p">,</span>
                <span class="n">yield_type</span><span class="o">=</span><span class="n">IterNodeType</span><span class="o">.</span><span class="n">VALUES</span>
                <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iter_group_items</span> <span class="o">=</span> <span class="n">IterNode</span><span class="p">(</span>
                <span class="n">container</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">function_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_axis_group_loc</span><span class="p">,</span>
                <span class="n">function_items</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_axis_group_loc_items</span><span class="p">,</span>
                <span class="n">yield_type</span><span class="o">=</span><span class="n">IterNodeType</span><span class="o">.</span><span class="n">ITEMS</span>
                <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">iter_element</span> <span class="o">=</span> <span class="n">IterNode</span><span class="p">(</span>
                <span class="n">container</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">function_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_iter_element_loc</span><span class="p">,</span>
                <span class="n">function_items</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_iter_element_loc_items</span><span class="p">,</span>
                <span class="n">yield_type</span><span class="o">=</span><span class="n">IterNodeType</span><span class="o">.</span><span class="n">VALUES</span><span class="p">,</span>
                <span class="n">apply_type</span><span class="o">=</span><span class="n">IterNodeApplyType</span><span class="o">.</span><span class="n">FRAME_ELEMENTS</span>
                <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iter_element_items</span> <span class="o">=</span> <span class="n">IterNode</span><span class="p">(</span>
                <span class="n">container</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">function_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_iter_element_loc</span><span class="p">,</span>
                <span class="n">function_items</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_iter_element_loc_items</span><span class="p">,</span>
                <span class="n">yield_type</span><span class="o">=</span><span class="n">IterNodeType</span><span class="o">.</span><span class="n">ITEMS</span><span class="p">,</span>
                <span class="n">apply_type</span><span class="o">=</span><span class="n">IterNodeApplyType</span><span class="o">.</span><span class="n">FRAME_ELEMENTS</span>
                <span class="p">)</span>


    <span class="c1">#---------------------------------------------------------------------------</span>
    <span class="c1"># index manipulation</span>

    <span class="k">def</span> <span class="nf">_reindex_other_like_iloc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">value</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="n">Series</span><span class="p">,</span> <span class="s1">&#39;Frame&#39;</span><span class="p">],</span>
            <span class="n">iloc_key</span><span class="p">:</span> <span class="n">GetItemKeyTypeCompound</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Frame&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;Given a value that is a Series or Frame, reindex it to the index components, drawn from this Frame, that are specified by the iloc_key.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">iloc_key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">row_key</span><span class="p">,</span> <span class="n">column_key</span> <span class="o">=</span> <span class="n">iloc_key</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">row_key</span><span class="p">,</span> <span class="n">column_key</span> <span class="o">=</span> <span class="n">iloc_key</span><span class="p">,</span> <span class="kc">None</span>

        <span class="c1"># within this frame, get Index objects by extracting based on passed-in iloc keys</span>
        <span class="n">axis_nm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_axis_not_multi</span><span class="p">(</span><span class="n">row_key</span><span class="p">,</span> <span class="n">column_key</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">axis_nm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">axis_nm</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="c1"># only column is multi</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="o">.</span><span class="n">_extract_iloc</span><span class="p">(</span><span class="n">column_key</span><span class="p">))</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">axis_nm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">axis_nm</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="c1"># only row is multi</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">_extract_iloc</span><span class="p">(</span><span class="n">row_key</span><span class="p">))</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">axis_nm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">axis_nm</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="c1"># both multi, must be a DF</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Frame</span><span class="p">):</span>
                <span class="n">target_column_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="o">.</span><span class="n">_extract_iloc</span><span class="p">(</span><span class="n">column_key</span><span class="p">)</span>
                <span class="n">target_row_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">_extract_iloc</span><span class="p">(</span><span class="n">row_key</span><span class="p">)</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">target_row_index</span><span class="p">,</span>
                        <span class="n">columns</span><span class="o">=</span><span class="n">target_column_index</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">((</span><span class="s1">&#39;cannot assign &#39;</span>
                    <span class="o">+</span> <span class="n">value</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
                    <span class="o">+</span> <span class="s1">&#39; with key configuration&#39;</span><span class="p">),</span> <span class="n">axis_nm</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">v</span>


<div class="viewcode-block" id="Frame.reindex"><a class="viewcode-back" href="../../../../overview.html#static_frame.Frame.reindex">[docs]</a>    <span class="k">def</span> <span class="nf">reindex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">index</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="n">Index</span><span class="p">,</span> <span class="n">tp</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="n">tp</span><span class="o">.</span><span class="n">Any</span><span class="p">]]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">columns</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="n">Index</span><span class="p">,</span> <span class="n">tp</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="n">tp</span><span class="o">.</span><span class="n">Any</span><span class="p">]]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Frame&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a new Frame based on the passed index and/or columns.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">columns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;must specify one of index or columns&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="n">index_ic</span> <span class="o">=</span> <span class="n">IndexCorrespondence</span><span class="o">.</span><span class="n">from_correspondence</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span>
            <span class="n">index_ic</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_COLUMN_CONSTRUCTOR</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span>
            <span class="n">columns_ic</span> <span class="o">=</span> <span class="n">IndexCorrespondence</span><span class="o">.</span><span class="n">from_correspondence</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="p">,</span> <span class="n">columns</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span>
            <span class="n">columns_ic</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
                <span class="n">TypeBlocks</span><span class="o">.</span><span class="n">from_blocks</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">resize_blocks</span><span class="p">(</span>
                        <span class="n">index_ic</span><span class="o">=</span><span class="n">index_ic</span><span class="p">,</span>
                        <span class="n">columns_ic</span><span class="o">=</span><span class="n">columns_ic</span><span class="p">,</span>
                        <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)),</span>
                        <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
                        <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span>
                        <span class="n">own_data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="Frame.relabel"><a class="viewcode-back" href="../../../../overview.html#static_frame.Frame.relabel">[docs]</a>    <span class="k">def</span> <span class="nf">relabel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">index</span><span class="p">:</span> <span class="n">CallableOrMapping</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">columns</span><span class="p">:</span> <span class="n">CallableOrMapping</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Frame&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a new Series based on a mapping (or callable) from old to new index values.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># create new index objects in both cases so as to call with own*</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="k">if</span> <span class="n">index</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span> <span class="k">if</span> <span class="n">columns</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
                <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span>
                <span class="n">own_data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">own_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">own_columns</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


    <span class="c1">#---------------------------------------------------------------------------</span>
    <span class="c1"># na handling</span>

<div class="viewcode-block" id="Frame.isna"><a class="viewcode-back" href="../../../../overview.html#static_frame.Frame.isna">[docs]</a>    <span class="k">def</span> <span class="nf">isna</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Frame&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a same-indexed, Boolean Frame indicating True which values are NaN or None.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># always return a Frame, even if this is a FrameGO</span>
        <span class="k">return</span> <span class="n">Frame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">isna</span><span class="p">(),</span>
                <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">,</span>
                <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="p">,</span>
                <span class="n">own_data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="Frame.notna"><a class="viewcode-back" href="../../../../overview.html#static_frame.Frame.notna">[docs]</a>    <span class="k">def</span> <span class="nf">notna</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Frame&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a same-indexed, Boolean Frame indicating True which values are not NaN or None.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># always return a Frame, even if this is a FrameGO</span>
        <span class="k">return</span> <span class="n">Frame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">notna</span><span class="p">(),</span>
                <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">,</span>
                <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="p">,</span>
                <span class="n">own_data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="Frame.dropna"><a class="viewcode-back" href="../../../../overview.html#static_frame.Frame.dropna">[docs]</a>    <span class="k">def</span> <span class="nf">dropna</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">condition</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Callable</span><span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Frame&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a new Frame after removing rows (axis 0) or columns (axis 1) where condition is True, where condition is an NumPy ufunc that process the Boolean array returned by isna().</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># returns Boolean areas that define axis to keep</span>
        <span class="n">row_key</span><span class="p">,</span> <span class="n">column_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">dropna_to_keep_locations</span><span class="p">(</span>
                <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                <span class="n">condition</span><span class="o">=</span><span class="n">condition</span><span class="p">)</span>

        <span class="c1"># NOTE: if not values to drop and this is a Frame (not a FrameGO) we can return self as it is immutable</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="n">Frame</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">row_key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">column_key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                    <span class="ow">and</span> <span class="n">row_key</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">and</span> <span class="n">column_key</span><span class="o">.</span><span class="n">all</span><span class="p">()):</span>
                <span class="k">return</span> <span class="bp">self</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract</span><span class="p">(</span><span class="n">row_key</span><span class="p">,</span> <span class="n">column_key</span><span class="p">)</span></div>

<div class="viewcode-block" id="Frame.fillna"><a class="viewcode-back" href="../../../../overview.html#static_frame.Frame.fillna">[docs]</a>    <span class="k">def</span> <span class="nf">fillna</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Frame&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;Return a new Frame after replacing NaN or None values with the supplied value.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">value</span><span class="p">),</span>
                <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">,</span>
                <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="p">,</span>
                <span class="n">own_data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>



    <span class="c1">#---------------------------------------------------------------------------</span>

<div class="viewcode-block" id="Frame.__len__"><a class="viewcode-back" href="../../../../overview.html#static_frame.Frame.__len__">[docs]</a>    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;Length of rows in values.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">display</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">:</span> <span class="n">DisplayConfig</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Display</span><span class="p">:</span>
        <span class="n">config</span> <span class="o">=</span> <span class="n">config</span> <span class="ow">or</span> <span class="n">DisplayActive</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>

        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">display</span><span class="p">(</span><span class="n">config</span><span class="o">=</span><span class="n">config</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">config</span><span class="o">.</span><span class="n">display_columns</span><span class="p">:</span>
            <span class="c1"># columns as they will look after application of truncation and insertion of ellipsis</span>
            <span class="c1"># get target column count in the absence of meta data, subtracting 2</span>
            <span class="n">data_half_count</span> <span class="o">=</span> <span class="n">Display</span><span class="o">.</span><span class="n">truncate_half_count</span><span class="p">(</span>
                    <span class="n">config</span><span class="o">.</span><span class="n">display_columns</span> <span class="o">-</span> <span class="n">Display</span><span class="o">.</span><span class="n">DATA_MARGINS</span><span class="p">)</span>

            <span class="n">column_gen</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_gen_skip_middle</span><span class="p">,</span>
                    <span class="n">forward_iter</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">axis_values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                    <span class="n">forward_count</span> <span class="o">=</span> <span class="n">data_half_count</span><span class="p">,</span>
                    <span class="n">reverse_iter</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">axis_values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                    <span class="n">reverse_count</span> <span class="o">=</span> <span class="n">data_half_count</span><span class="p">,</span>
                    <span class="n">center_sentinel</span> <span class="o">=</span> <span class="n">Display</span><span class="o">.</span><span class="n">ELLIPSIS_CENTER_SENTINEL</span>
                    <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">column_gen</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">axis_values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">column_gen</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">column</span> <span class="ow">is</span> <span class="n">Display</span><span class="o">.</span><span class="n">ELLIPSIS_CENTER_SENTINEL</span><span class="p">:</span>
                <span class="n">d</span><span class="o">.</span><span class="n">append_ellipsis</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">d</span><span class="o">.</span><span class="n">append_iterable</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="n">cls_display</span> <span class="o">=</span> <span class="n">Display</span><span class="o">.</span><span class="n">from_values</span><span class="p">((),</span>
                <span class="n">header</span><span class="o">=</span><span class="s1">&#39;&lt;&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;&gt;&#39;</span><span class="p">,</span>
                <span class="n">config</span><span class="o">=</span><span class="n">config</span><span class="p">)</span>
        <span class="c1"># add two rows, one for class, another for columns</span>

        <span class="c1"># need to apply the column config such that it truncates it based on the the max columns, not the max rows</span>
        <span class="n">config_column</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">to_transpose</span><span class="p">()</span>
        <span class="n">d</span><span class="o">.</span><span class="n">insert_rows</span><span class="p">(</span>
                <span class="n">cls_display</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="o">.</span><span class="n">display</span><span class="p">(</span><span class="n">config</span><span class="o">=</span><span class="n">config_column</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">())</span>

    <span class="c1">#---------------------------------------------------------------------------</span>
    <span class="c1"># accessors</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">values</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span>

    <span class="c1"># @index.setter</span>
    <span class="c1"># def index(self, value):</span>
    <span class="c1">#     if len(value) != len(self._index):</span>
    <span class="c1">#         raise Exception(&#39;new index must match length of old index&#39;)</span>
    <span class="c1">#     self._index = Index(value)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">columns</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span>

    <span class="c1"># @columns.setter</span>
    <span class="c1"># def columns(self, value):</span>
    <span class="c1">#     if len(value) != len(self._columns):</span>
    <span class="c1">#         raise Exception(&#39;new columns must match length of old index&#39;)</span>
    <span class="c1">#     self._columns = self._COLUMN_CONSTRUCTOR(value)</span>

    <span class="c1">#---------------------------------------------------------------------------</span>
    <span class="c1"># common attributes from the numpy array</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtypes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;Return a Series of dytpes for each realizable column.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">dtypes</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mloc</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;Return an immutable ndarray of NP array memory location integers.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">mloc</span>

    <span class="c1">#---------------------------------------------------------------------------</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tp</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">ndim</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">size</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nbytes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">nbytes</span>

    <span class="c1">#---------------------------------------------------------------------------</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_extract_axis_not_multi</span><span class="p">(</span><span class="n">row_key</span><span class="p">,</span> <span class="n">column_key</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tp</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        If either row or column is given with a non-multiple type of selection, reduce dimensionality.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">row_nm</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">column_nm</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">row_key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">row_key</span><span class="p">,</span> <span class="n">_KEY_MULTIPLE_TYPES</span><span class="p">):</span>
            <span class="n">row_nm</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># axis 0</span>
        <span class="k">if</span> <span class="n">column_key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column_key</span><span class="p">,</span> <span class="n">_KEY_MULTIPLE_TYPES</span><span class="p">):</span>
            <span class="n">column_nm</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># axis 1</span>
        <span class="k">return</span> <span class="n">row_nm</span><span class="p">,</span> <span class="n">column_nm</span>


    <span class="k">def</span> <span class="nf">_extract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">row_key</span><span class="p">:</span> <span class="n">GetItemKeyType</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">column_key</span><span class="p">:</span> <span class="n">GetItemKeyType</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tp</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="s1">&#39;Frame&#39;</span><span class="p">,</span> <span class="n">Series</span><span class="p">]:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Extract based on iloc selection.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">blocks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">_extract</span><span class="p">(</span><span class="n">row_key</span><span class="o">=</span><span class="n">row_key</span><span class="p">,</span> <span class="n">column_key</span><span class="o">=</span><span class="n">column_key</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">blocks</span><span class="p">,</span> <span class="n">TypeBlocks</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">blocks</span> <span class="c1"># reduced to element</span>

        <span class="k">if</span> <span class="n">row_key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># have to accept 9!</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">row_key</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span>

        <span class="k">if</span> <span class="n">column_key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="p">[</span><span class="n">column_key</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span>

        <span class="n">axis_nm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_axis_not_multi</span><span class="p">(</span><span class="n">row_key</span><span class="p">,</span> <span class="n">column_key</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">blocks</span><span class="o">.</span><span class="n">_shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># if TypeBlocks did not return an element, need to determine which axis to use for Series index</span>
            <span class="k">if</span> <span class="n">axis_nm</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="c1"># if row not multi</span>
                <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="n">blocks</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">axis_nm</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="n">blocks</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>
            <span class="c1"># if both are multi, we return a Fram</span>
        <span class="k">elif</span> <span class="n">blocks</span><span class="o">.</span><span class="n">_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># if one row</span>
            <span class="k">if</span> <span class="n">axis_nm</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="c1"># if row key not multi</span>
                <span class="c1"># best to use blocks.values, as will need to consolidate if necessary</span>
                <span class="n">block</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="n">values</span>
                <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># 2d block, get teh first row</span>
                    <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">blocks</span><span class="o">.</span><span class="n">_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># if one column</span>
            <span class="k">if</span> <span class="n">axis_nm</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="c1"># if column key is not multi</span>
                <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="n">blocks</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">blocks</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_extract_iloc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">GetItemKeyTypeCompound</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Frame&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract</span><span class="p">(</span><span class="o">*</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract</span><span class="p">(</span><span class="n">row_key</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_compound_loc_to_iloc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">key</span><span class="p">:</span> <span class="n">GetItemKeyTypeCompound</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tp</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">GetItemKeyType</span><span class="p">,</span> <span class="n">GetItemKeyType</span><span class="p">]:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Given a compound iloc key, return a tuple of row, column keys. Assumes the first argument is always a row extractor.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">loc_row_key</span><span class="p">,</span> <span class="n">loc_column_key</span> <span class="o">=</span> <span class="n">key</span>
            <span class="n">iloc_column_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="o">.</span><span class="n">loc_to_iloc</span><span class="p">(</span><span class="n">loc_column_key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">loc_row_key</span> <span class="o">=</span> <span class="n">key</span>
            <span class="n">iloc_column_key</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">iloc_row_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">loc_to_iloc</span><span class="p">(</span><span class="n">loc_row_key</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">iloc_row_key</span><span class="p">,</span> <span class="n">iloc_column_key</span>

    <span class="k">def</span> <span class="nf">_compound_loc_to_getitem_iloc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">key</span><span class="p">:</span> <span class="n">GetItemKeyTypeCompound</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tp</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">GetItemKeyType</span><span class="p">,</span> <span class="n">GetItemKeyType</span><span class="p">]:</span>
        <span class="sd">&#39;&#39;&#39;Handle a potentially compound key in the style of __getitem__</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;__getitem__ does not support multiple indexers&#39;</span><span class="p">)</span>
        <span class="n">iloc_column_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="o">.</span><span class="n">loc_to_iloc</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">iloc_column_key</span>


    <span class="k">def</span> <span class="nf">_extract_loc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">GetItemKeyTypeCompound</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Frame&#39;</span><span class="p">:</span>
        <span class="n">iloc_row_key</span><span class="p">,</span> <span class="n">iloc_column_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compound_loc_to_iloc</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract</span><span class="p">(</span><span class="n">row_key</span><span class="o">=</span><span class="n">iloc_row_key</span><span class="p">,</span>
                <span class="n">column_key</span><span class="o">=</span><span class="n">iloc_column_key</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">GetItemKeyType</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_compound_loc_to_getitem_iloc</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>


    <span class="c1">#---------------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">_extract_iloc_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">GetItemKeyTypeCompound</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Frame&#39;</span><span class="p">:</span>
        <span class="n">masked_blocks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">extract_iloc_mask</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">masked_blocks</span><span class="p">,</span>
                <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">,</span>
                <span class="n">own_data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_extract_loc_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">GetItemKeyTypeCompound</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Frame&#39;</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compound_loc_to_iloc</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_iloc_mask</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_extract_getitem_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">GetItemKeyTypeCompound</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Frame&#39;</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compound_loc_to_getitem_iloc</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_iloc_mask</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>



    <span class="k">def</span> <span class="nf">_extract_iloc_masked_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">GetItemKeyTypeCompound</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MaskedArray</span><span class="p">:</span>
        <span class="n">masked_blocks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">extract_iloc_mask</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">MaskedArray</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">masked_blocks</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_extract_loc_masked_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">GetItemKeyTypeCompound</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MaskedArray</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compound_loc_to_iloc</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_iloc_masked_array</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_extract_getitem_masked_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">GetItemKeyTypeCompound</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Frame&#39;</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compound_loc_to_getitem_iloc</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_iloc_masked_array</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>

    <span class="c1">#---------------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">_extract_iloc_assign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">GetItemKeyTypeCompound</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;FrameAssign&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">FrameAssign</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">iloc_key</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_extract_loc_assign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">GetItemKeyTypeCompound</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;FrameAssign&#39;</span><span class="p">:</span>
        <span class="c1"># extract if tuple, then pack back again</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compound_loc_to_iloc</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_iloc_assign</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_extract_getitem_assign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">GetItemKeyTypeCompound</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;FrameAssign&#39;</span><span class="p">:</span>
        <span class="c1"># extract if tuple, then pack back again</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compound_loc_to_getitem_iloc</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extract_iloc_assign</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>

    <span class="c1">#---------------------------------------------------------------------------</span>
    <span class="c1"># dictionary-like interface</span>

<div class="viewcode-block" id="Frame.keys"><a class="viewcode-back" href="../../../../overview.html#static_frame.Frame.keys">[docs]</a>    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Iterator of column labels.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span></div>

<div class="viewcode-block" id="Frame.__iter__"><a class="viewcode-back" href="../../../../overview.html#static_frame.Frame.__iter__">[docs]</a>    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Iterator of column labels, same as :py:meth:`Frame.keys`.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">()</span></div>

<div class="viewcode-block" id="Frame.__contains__"><a class="viewcode-back" href="../../../../overview.html#static_frame.Frame.__contains__">[docs]</a>    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Inclusion of value in column labels.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="o">.</span><span class="fm">__contains__</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="Frame.items"><a class="viewcode-back" href="../../../../overview.html#static_frame.Frame.items">[docs]</a>    <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tp</span><span class="o">.</span><span class="n">Generator</span><span class="p">[</span><span class="n">tp</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">tp</span><span class="o">.</span><span class="n">Any</span><span class="p">,</span> <span class="n">Series</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&#39;&#39;&#39;Iterator of pairs of column label and corresponding column :py:class:`Series`.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="p">(</span><span class="n">Series</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">axis_values</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span></div>

<div class="viewcode-block" id="Frame.get"><a class="viewcode-back" href="../../../../overview.html#static_frame.Frame.get">[docs]</a>    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return the value found at the columns key, else the default if the key is not found.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">default</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span></div>


    <span class="c1">#---------------------------------------------------------------------------</span>
    <span class="c1"># operator functions</span>

    <span class="k">def</span> <span class="nf">_ufunc_unary_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Callable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Frame&#39;</span><span class="p">:</span>
        <span class="c1"># call the unary operator on _blocks</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">_ufunc_unary_operator</span><span class="p">(</span><span class="n">operator</span><span class="o">=</span><span class="n">operator</span><span class="p">),</span>
                <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">,</span>
                <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_ufunc_binary_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Frame</span><span class="p">):</span>
            <span class="c1"># reindex both dimensions to union indices</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_columns</span><span class="p">)</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_index</span><span class="p">)</span>
            <span class="n">self_tb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">_blocks</span>
            <span class="n">other_tb</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">_blocks</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">self_tb</span><span class="o">.</span><span class="n">_ufunc_binary_operator</span><span class="p">(</span>
                    <span class="n">operator</span><span class="o">=</span><span class="n">operator</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other_tb</span><span class="p">),</span>
                    <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
                    <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span>
                    <span class="n">own_data</span><span class="o">=</span><span class="kc">True</span>
                    <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_index</span><span class="p">)</span>
            <span class="n">self_tb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span><span class="o">.</span><span class="n">_blocks</span>
            <span class="n">other_array</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">self_tb</span><span class="o">.</span><span class="n">_ufunc_binary_operator</span><span class="p">(</span>
                    <span class="n">operator</span><span class="o">=</span><span class="n">operator</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other_array</span><span class="p">),</span>
                    <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">,</span>
                    <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span>
                    <span class="n">own_data</span><span class="o">=</span><span class="kc">True</span>
                    <span class="p">)</span>
        <span class="c1"># handle single values and lists that can be converted to appropriate arrays</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="c1"># assume we will keep dimensionality</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">_ufunc_binary_operator</span><span class="p">(</span>
                <span class="n">operator</span><span class="o">=</span><span class="n">operator</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">),</span>
                <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">,</span>
                <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="p">,</span>
                <span class="n">own_data</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>

    <span class="c1">#---------------------------------------------------------------------------</span>
    <span class="c1"># axis functions</span>

    <span class="k">def</span> <span class="nf">_ufunc_axis_skipna</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="p">,</span> <span class="n">ufunc</span><span class="p">,</span> <span class="n">ufunc_skipna</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
        <span class="c1"># axis 0 sums ros, deliveres column index</span>
        <span class="c1"># axis 1 sums cols, delivers row index</span>
        <span class="k">assert</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="mi">2</span>

        <span class="c1"># TODO: need to handle replacing None with nan in object blocks!</span>
        <span class="k">if</span> <span class="n">skipna</span><span class="p">:</span>
            <span class="n">post</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">block_apply_axis</span><span class="p">(</span><span class="n">ufunc_skipna</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">post</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">block_apply_axis</span><span class="p">(</span><span class="n">ufunc</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="c1"># post has been made immutable so Series will own</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="n">post</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="n">post</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">)</span>

    <span class="c1">#---------------------------------------------------------------------------</span>
    <span class="c1"># axis iterators</span>
    <span class="c1"># NOTE: if there is more than one argument, the axis argument needs to be key-word only</span>

    <span class="k">def</span> <span class="nf">_axis_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Generator of arrays across an axis</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">axis_values</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_axis_array_items</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span>
        <span class="k">yield from</span> <span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">axis_values</span><span class="p">(</span><span class="n">axis</span><span class="p">))</span>


    <span class="k">def</span> <span class="nf">_axis_tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Generator of named tuples across an axis.</span>

<span class="sd">        Args:</span>
<span class="sd">            axis: 0 iterates over columns (index axis), 1 iterates over rows (column axis)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">Tuple</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Axis&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">Tuple</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Axis&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">axis_values</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">axis_values</span><span class="p">(</span><span class="n">axis</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">Tuple</span><span class="p">(</span><span class="o">*</span><span class="n">axis_values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_axis_tuple_items</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span>
        <span class="k">yield from</span> <span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_axis_tuple</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">))</span>


    <span class="k">def</span> <span class="nf">_axis_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Generator of Series across an axis</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="o">.</span><span class="n">values</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span>
        <span class="k">for</span> <span class="n">axis_values</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">axis_values</span><span class="p">(</span><span class="n">axis</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">Series</span><span class="p">(</span><span class="n">axis_values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_axis_series_items</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span>
        <span class="k">yield from</span> <span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_axis_series</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">))</span>


    <span class="c1">#---------------------------------------------------------------------------</span>
    <span class="c1"># grouping methods naturally return their &quot;index&quot; as the group element</span>

    <span class="k">def</span> <span class="nf">_axis_group_iloc_items</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">group</span><span class="p">,</span> <span class="n">selection</span><span class="p">,</span> <span class="n">tb</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># axis 0 is a row iter, so need to slice index, keep columns</span>
                <span class="k">yield</span> <span class="n">group</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span>
                        <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">selection</span><span class="p">],</span>
                        <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                        <span class="n">own_data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># axis 1 is a column iterators, so need to slice columns, keep index</span>
                <span class="k">yield</span> <span class="n">group</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span>
                        <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">,</span>
                        <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="p">[</span><span class="n">selection</span><span class="p">],</span>
                        <span class="n">own_data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_axis_group_loc_items</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># row iterator, selecting columns for group by</span>
            <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="o">.</span><span class="n">loc_to_iloc</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># column iterator, selecting rows for group by</span>
            <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">loc_to_iloc</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_axis_group_iloc_items</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_axis_group_loc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">yield from</span> <span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_axis_group_loc_items</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">))</span>


    <span class="c1">#---------------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">_iter_element_iloc_items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">element_items</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_iter_element_iloc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">yield from</span> <span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iter_element_iloc_items</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_iter_element_loc_items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">yield from</span> <span class="p">(</span>
                <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]]),</span> <span class="n">v</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">element_items</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_iter_element_loc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">yield from</span> <span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iter_element_loc_items</span><span class="p">())</span>


    <span class="c1">#---------------------------------------------------------------------------</span>
    <span class="c1"># transformations resulting in the same dimensionality</span>

<div class="viewcode-block" id="Frame.sort_index"><a class="viewcode-back" href="../../../../overview.html#static_frame.Frame.sort_index">[docs]</a>    <span class="k">def</span> <span class="nf">sort_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">ascending</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="n">_DEFAULT_SORT_KIND</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Frame&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a new Frame ordered by the sorted Index.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># argsort lets us do the sort once and reuse the results</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ascending</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">index_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>
        <span class="n">index_values</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">blocks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">blocks</span><span class="p">,</span>
                <span class="n">index</span><span class="o">=</span><span class="n">index_values</span><span class="p">,</span>
                <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="p">,</span>
                <span class="n">own_data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="Frame.sort_columns"><a class="viewcode-back" href="../../../../overview.html#static_frame.Frame.sort_columns">[docs]</a>    <span class="k">def</span> <span class="nf">sort_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">ascending</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">kind</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="n">_DEFAULT_SORT_KIND</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Frame&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a new Frame ordered by the sorted Columns.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># argsort lets us do the sort once and reuse the results</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ascending</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">columns_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>
        <span class="n">columns_values</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">blocks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">blocks</span><span class="p">,</span>
                <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">,</span>
                <span class="n">columns</span><span class="o">=</span><span class="n">columns_values</span><span class="p">,</span>
                <span class="n">own_data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="Frame.sort_values"><a class="viewcode-back" href="../../../../overview.html#static_frame.Frame.sort_values">[docs]</a>    <span class="k">def</span> <span class="nf">sort_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">key</span><span class="p">:</span> <span class="n">KeyOrKeys</span><span class="p">,</span>
            <span class="n">ascending</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">kind</span><span class="o">=</span><span class="n">_DEFAULT_SORT_KIND</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Frame&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a new Frame ordered by the sorted values, where values is given by one or more columns.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># argsort lets us do the sort once and reuse the results</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># get a column ordering</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">:</span>
                <span class="n">iloc_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">loc_to_iloc</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">iloc_key</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># assume an iterable of keys</span>
                <span class="c1"># order so that highest priority is last</span>
                <span class="n">iloc_keys</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">loc_to_iloc</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
                <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">iloc_keys</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="p">:</span>
                <span class="n">iloc_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="o">.</span><span class="n">loc_to_iloc</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">[</span><span class="n">iloc_key</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># assume an iterable of keys</span>
                <span class="c1"># order so that highest priority is last</span>
                <span class="n">iloc_keys</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="o">.</span><span class="n">loc_to_iloc</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
                <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">iloc_keys</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">ascending</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">column_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>
            <span class="n">column_values</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">blocks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">blocks</span><span class="p">,</span>
                    <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">,</span>
                    <span class="n">columns</span><span class="o">=</span><span class="n">column_values</span><span class="p">,</span>
                    <span class="n">own_data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">index_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>
        <span class="n">index_values</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">blocks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">blocks</span><span class="p">,</span>
                <span class="n">index</span><span class="o">=</span><span class="n">index_values</span><span class="p">,</span>
                <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="p">,</span>
                <span class="n">own_data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="Frame.isin"><a class="viewcode-back" href="../../../../overview.html#static_frame.Frame.isin">[docs]</a>    <span class="k">def</span> <span class="nf">isin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Frame&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a same-sized Boolean Frame that shows if the same-positioned element is in the iterable passed to the function.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># cannot use assume_unique because do not know if values is unique</span>
        <span class="n">v</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_iterable_to_array</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="c1"># TODO: is it faster to do this at the block level and return blocks?</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="n">array</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">)</span></div>

<div class="viewcode-block" id="Frame.transpose"><a class="viewcode-back" href="../../../../overview.html#static_frame.Frame.transpose">[docs]</a>    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Frame&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;Return a tansposed version of the Frame.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span>
                <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="p">,</span>
                <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">,</span>
                <span class="n">own_data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">T</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Frame&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>


<div class="viewcode-block" id="Frame.duplicated"><a class="viewcode-back" href="../../../../overview.html#static_frame.Frame.duplicated">[docs]</a>    <span class="k">def</span> <span class="nf">duplicated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">exclude_first</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">exclude_last</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Series&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return an axis-sized Boolean Series that shows True for all rows (axis 0) or columns (axis 1) duplicated.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># NOTE: can avoid calling .vaalues with extensions to TypeBlocks</span>
        <span class="n">duplicates</span> <span class="o">=</span> <span class="n">_array_to_duplicated</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                <span class="n">exclude_first</span><span class="o">=</span><span class="n">exclude_first</span><span class="p">,</span>
                <span class="n">exclude_last</span><span class="o">=</span><span class="n">exclude_last</span><span class="p">)</span>
        <span class="n">duplicates</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># index is index</span>
            <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="n">duplicates</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="n">duplicates</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="p">)</span></div>

<div class="viewcode-block" id="Frame.drop_duplicated"><a class="viewcode-back" href="../../../../overview.html#static_frame.Frame.drop_duplicated">[docs]</a>    <span class="k">def</span> <span class="nf">drop_duplicated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">exclude_first</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">exclude_last</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Frame&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a Frame with duplicated values removed.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># NOTE: can avoid calling .vaalues with extensions to TypeBlocks</span>
        <span class="n">duplicates</span> <span class="o">=</span> <span class="n">_array_to_duplicated</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                <span class="n">exclude_first</span><span class="o">=</span><span class="n">exclude_first</span><span class="p">,</span>
                <span class="n">exclude_last</span><span class="o">=</span><span class="n">exclude_last</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">duplicates</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">keep</span> <span class="o">=</span> <span class="o">~</span><span class="n">duplicates</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># return rows with index indexed</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">keep</span><span class="p">],</span>
                    <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">keep</span><span class="p">],</span>
                    <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[:,</span> <span class="n">keep</span><span class="p">],</span>
                <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">,</span>
                <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="p">[</span><span class="n">keep</span><span class="p">])</span></div>

    <span class="c1">#---------------------------------------------------------------------------</span>
    <span class="c1"># utility function to numpy array</span>

<div class="viewcode-block" id="Frame.unique"><a class="viewcode-back" href="../../../../overview.html#static_frame.Frame.unique">[docs]</a>    <span class="k">def</span> <span class="nf">unique</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a NumPy array of unqiue values. If the axis argument is provied, uniqueness is determined by columns or row.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span></div>

    <span class="c1">#---------------------------------------------------------------------------</span>
    <span class="c1"># exporters</span>

<div class="viewcode-block" id="Frame.to_pairs"><a class="viewcode-back" href="../../../../overview.html#static_frame.Frame.to_pairs">[docs]</a>    <span class="k">def</span> <span class="nf">to_pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tp</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span>
            <span class="n">tp</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">tp</span><span class="o">.</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">tp</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="n">tp</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">tp</span><span class="o">.</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">tp</span><span class="o">.</span><span class="n">Any</span><span class="p">]]]]:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a tuple of major axis key, minor axis key vlaue pairs, where major axis is determined by the axis argument.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">major</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">values</span>
            <span class="n">minor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="o">.</span><span class="n">values</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">major</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="o">.</span><span class="n">values</span>
            <span class="n">minor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="nb">zip</span><span class="p">(</span><span class="n">major</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">minor</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">axis_values</span><span class="p">(</span><span class="n">axis</span><span class="p">))))</span></div>

<div class="viewcode-block" id="Frame.to_pandas"><a class="viewcode-back" href="../../../../overview.html#static_frame.Frame.to_pandas">[docs]</a>    <span class="k">def</span> <span class="nf">to_pandas</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a Pandas DataFrame.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">import</span> <span class="nn">pandas</span>
        <span class="k">return</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span></div>

    <span class="k">def</span> <span class="nf">to_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">fp</span><span class="p">:</span> <span class="n">FilePathOrFileLike</span><span class="p">,</span>
            <span class="n">sep</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span>
            <span class="n">include_index</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">include_columns</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">encoding</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">line_terminator</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Given a file path or file-like object, write the Frame as delimited text.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">to_str</span> <span class="o">=</span> <span class="nb">str</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">)</span>
            <span class="n">is_file</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">fp</span> <span class="c1"># assume an open file like</span>
            <span class="n">is_file</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">include_columns</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">include_index</span><span class="p">:</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;index&#39;</span> <span class="o">+</span> <span class="n">sep</span><span class="p">)</span>
                <span class="c1"># iter directly over columns in case it is an IndexGO and needs to update cache</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">sep</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">to_str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="p">))</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line_terminator</span><span class="p">)</span>

            <span class="n">col_idx_last</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="c1"># avoid row creation to avoid joining types; avoide creating a list for each row</span>
            <span class="n">row_current_idx</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">row_idx</span><span class="p">,</span> <span class="n">col_idx</span><span class="p">),</span> <span class="n">element</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iter_element_iloc_items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">row_idx</span> <span class="o">!=</span> <span class="n">row_current_idx</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">row_current_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line_terminator</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">include_index</span><span class="p">:</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">_labels</span><span class="p">[</span><span class="n">row_idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">sep</span><span class="p">)</span>
                    <span class="n">row_current_idx</span> <span class="o">=</span> <span class="n">row_idx</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">to_str</span><span class="p">(</span><span class="n">element</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">col_idx</span> <span class="o">!=</span> <span class="n">col_idx_last</span><span class="p">:</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
            <span class="c1"># not sure if we need a final line terminator</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_file</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">is_file</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">to_tsv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">fp</span><span class="p">:</span> <span class="n">FilePathOrFileLike</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">fp</span><span class="o">=</span><span class="n">fp</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="FrameGO"><a class="viewcode-back" href="../../../../overview.html#static_frame.FrameGO">[docs]</a><span class="k">class</span> <span class="nc">FrameGO</span><span class="p">(</span><span class="n">Frame</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;A two-dimensional ordered, labelled collection, immutable with grow-only columns.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s1">&#39;_blocks&#39;</span><span class="p">,</span>
        <span class="s1">&#39;_columns&#39;</span><span class="p">,</span>
        <span class="s1">&#39;_index&#39;</span><span class="p">,</span>
        <span class="s1">&#39;iloc&#39;</span><span class="p">,</span>
        <span class="s1">&#39;loc&#39;</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="n">_COLUMN_CONSTRUCTOR</span> <span class="o">=</span> <span class="n">IndexGO</span>


    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;For adding a single column, one column at a time.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;key already defined in columns; use .assign to get new Frame&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
            <span class="c1"># TODO: performance test if it is faster to compare indices and not call reindex() if we can avoid it?</span>
            <span class="c1"># select only the values matching our index</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># unindexed array</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">GeneratorType</span><span class="p">):</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">value</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># for now, we assume all values make sense to covnert to NP array</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="n">value</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;incorrectly sized, unindexed value&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="c1"># this might fail if key is a sequence</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">extend_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">keys</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Iterable</span><span class="p">,</span>
            <span class="n">values</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Extend the FrameGO (add more columns) by providing two iterables, one for column names and antoher for appropriately sized iterables.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">zip_longest</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">extend_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">keys</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Iterable</span><span class="p">,</span>
            <span class="n">values</span><span class="p">:</span> <span class="n">tp</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]):</span>
        <span class="sd">&#39;&#39;&#39;Extend the FrameGO (add more columns) by providing two iterables, one of needed column names (not nested), and an iterable of blocks (definting one or more columns in an ndarray).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
        <span class="c1"># TypeBlocks only accepts ndarrays; can try to convert here if lists or tuples given</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="n">value</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_columns</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;incompatible keys and values&#39;</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frame</span><span class="p">:</span> <span class="s1">&#39;FrameGO&#39;</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Extend by simply extending this frames blocks.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>


<span class="k">class</span> <span class="nc">FrameAssign</span><span class="p">:</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;iloc_key&#39;</span><span class="p">,)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
            <span class="n">data</span><span class="p">:</span> <span class="n">Frame</span><span class="p">,</span>
            <span class="n">iloc_key</span><span class="p">:</span> <span class="n">GetItemKeyTypeCompound</span>
            <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iloc_key</span> <span class="o">=</span> <span class="n">iloc_key</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="n">Series</span><span class="p">,</span> <span class="n">Frame</span><span class="p">)):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_reindex_other_like_iloc</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloc_key</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>

        <span class="n">blocks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">extract_iloc_assign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iloc_key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="c1"># can own the newly created block given by extract</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="n">blocks</span><span class="p">,</span>
                <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
                <span class="n">own_data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>





</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Christopher Ariza.
      Last updated on May 03, 2018.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../../',
            VERSION:'0.1a1',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>